<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>机器学习入门(1)</title>
    <link href="/2022/10/24/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8-1/"/>
    <url>/2022/10/24/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8-1/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>LaTex Beamer 笔记</title>
    <link href="/2022/10/10/LaTex-Beamer-%E6%95%99%E7%A8%8B/main/"/>
    <url>/2022/10/10/LaTex-Beamer-%E6%95%99%E7%A8%8B/main/</url>
    
    <content type="html"><![CDATA[<h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><p>LaTex用户使用beamer来制作ppt</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LaTex</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LaTex Beamer 教程</title>
    <link href="/2022/10/10/LaTex-Beamer-%E6%95%99%E7%A8%8B/"/>
    <url>/2022/10/10/LaTex-Beamer-%E6%95%99%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>post</title>
    <link href="/2022/10/09/post-1/"/>
    <url>/2022/10/09/post-1/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>MSVC编译器编码问题</title>
    <link href="/2022/09/29/post/"/>
    <url>/2022/09/29/post/</url>
    
    <content type="html"><![CDATA[<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>CLion的默认编码是UTF-8。坑爹的是MSVC编译器接收的源代码编码默认是GBK，所以CLion + MSVC会遇到很多奇形怪状的问题……</p><h3 id="MSVC编译器编码问题"><a href="#MSVC编译器编码问题" class="headerlink" title="MSVC编译器编码问题"></a>MSVC编译器编码问题</h3><p>MSVC编译器有两个编译选项，**/source-charset:**, **/execution-charset:**，顾名思义，前者指定传递给编译器的源文件的编码，后者指定编译出的BIN中的字符串所使用的编码</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">if</span><span class="hljs-params">(WIN32)</span></span><br><span class="hljs-function"><span class="hljs-title">target_compile_options</span><span class="hljs-params">(classify_fuying PUBLIC <span class="hljs-string">&quot;/source-charset:utf-8&quot;</span>)</span></span><br><span class="hljs-function"><span class="hljs-title">target_compile_options</span><span class="hljs-params">(classify_fuying PUBLIC <span class="hljs-string">&quot;/execution-charset:gbk&quot;</span>)</span></span><br><span class="hljs-function"><span class="hljs-title">endif</span><span class="hljs-params">()</span></span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CMake</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2022/09/17/hello-world/"/>
    <url>/2022/09/17/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>如何使用VSCode流畅地编写IDA Python脚本</title>
    <link href="/2022/09/03/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8VSCode%E6%B5%81%E7%95%85%E5%9C%B0%E7%BC%96%E5%86%99IDA_Python%E8%84%9A%E6%9C%AC/"/>
    <url>/2022/09/03/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8VSCode%E6%B5%81%E7%95%85%E5%9C%B0%E7%BC%96%E5%86%99IDA_Python%E8%84%9A%E6%9C%AC/</url>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>radare2的分析结果与IDA相比差距仍然是较大的，还是有必要使用IDA完成自动化分析工作。本文的内容涵盖如何搭建IDA Python脚本开发环境以及IDA Batch Mode使用入门教程</p><span id="more"></span><h3 id="VSCode环境配置"><a href="#VSCode环境配置" class="headerlink" title="VSCode环境配置"></a>VSCode环境配置</h3><p>为了获得代码补全功能，需要配置一下vscode。点击 运行 —— 打开配置，在settings.json中，添加”python.analysis.extraPaths”项，将它设置为IDA Python的模块目录<br><img src="/images/2022/09/2576976518.png" alt="0.png"></p><h3 id="IDA-Batch-Mode"><a href="#IDA-Batch-Mode" class="headerlink" title="IDA Batch Mode"></a>IDA Batch Mode</h3><p>IDA有GUI与CUI两个版本，在现阶段，CUI版本对应idat.exe与idat64.exe。显然，CUI版本比GUI版本需要的资源开销更少。Batch Mode的意思是批处理模式，应用场景是提取大量样本的信息</p><h4 id="进入Batch-Mode"><a href="#进入Batch-Mode" class="headerlink" title="进入Batch Mode"></a>进入Batch Mode</h4><p>在cmd.exe中（不要使用windows terminal，有非常奇怪的bug），执行如下命令，它的含义是调用CUI版本的IDA分析目标可执行文件，并调用待执行脚本.py。-B表示Batch Mode，如果不指定这个选项，IDA会进入与用户交互的状态，让用户选择一些分析参数，这会导致自动化流程“卡住”。目测，待执行脚本.py的路径中不能有空格，我的建议是将脚本放在IDA目录下，这样就可以直接以脚本名.py指定它</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">idat.exe</span> -<span class="hljs-keyword">B</span> -S<span class="hljs-string">&quot;待执行脚本.py 传递给脚本的参数1 参数2&quot;</span> 目标可执行文件<br></code></pre></td></tr></table></figure><h4 id="待执行脚本-py编写"><a href="#待执行脚本-py编写" class="headerlink" title="待执行脚本.py编写"></a>待执行脚本.py编写</h4><p>有三个点需要注意：1) IDA并不是等分析结束后才调用脚本，分析过程中就会调用脚本，因此，我们要在脚本中添加代码等待IDA分析完成，否则因为分析结果不完整，会出现脚本执行结果与预期不符的情况；2) 需要在脚本中执行退出命令，IDA并不会自行退出；3) 在-S中传递给脚本的参数，不能通过sys.argv获取到，要通过idc.ARGV获取，idc.ARGV<a href="/images/2022/09/2576976518.png">1</a>对应传递的第一个参数</p><p>一个模板脚本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> sys<br><br><span class="hljs-keyword">import</span> ida_auto<br><span class="hljs-keyword">import</span> idaapi<br><span class="hljs-keyword">import</span> idautils<br><span class="hljs-keyword">import</span> idc<br><br>ida_auto.auto_wait() <span class="hljs-comment"># 等待IDA分析完成</span><br><br>f = <span class="hljs-built_in">open</span>(<span class="hljs-string">r&quot;E:\FUCK.TXT&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>) <span class="hljs-comment"># 创建文件输出结果</span><br>f.write(idc.ARGV[<span class="hljs-number">1</span>]) <span class="hljs-comment"># 向文件中写入第一个参数</span><br>f.write(<span class="hljs-string">&quot;\n&quot;</span>)<br>f.write(<span class="hljs-string">&quot;I RUN\n&quot;</span>)<br><br>f.write(<span class="hljs-string">&quot;\n&quot;</span>)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;count %d&#x27;</span> % <span class="hljs-built_in">len</span>(<span class="hljs-built_in">list</span>(idautils.Functions())))<br><span class="hljs-keyword">for</span> ea <span class="hljs-keyword">in</span> idautils.Functions():<br>    f.write(<span class="hljs-built_in">hex</span>(ea) + idc.get_func_name(ea) + <span class="hljs-string">&quot;\n&quot;</span>) <span class="hljs-comment"># 打印出所有函数的起始地址与函数名</span><br>f.close()<br><br><br>idc.qexit(<span class="hljs-number">0</span>) <span class="hljs-comment"># 提取完所需信息后，退出IDA</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>逆向</category>
      
      <category>开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IDA</tag>
      
      <tag>IDA PRO</tag>
      
      <tag>逆向自动化</tag>
      
      <tag>流程化工作</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++实现std::mem_fn</title>
    <link href="/2022/08/30/C++%E5%AE%9E%E7%8E%B0stdmem_fn/"/>
    <url>/2022/08/30/C++%E5%AE%9E%E7%8E%B0stdmem_fn/</url>
    
    <content type="html"><![CDATA[<p>mem_fn，顾名思义，是指向类成员函数的指针，调用非静态的类成员函数时，需要传递一个隐含的参数self指针，以调用a.func()为例，编译器帮助我们完成了传递self指针的过程，但有时候我们有这样的需求，获取A.func的指针，然后依次传递a,b,c,d,…等作为self参数去调用A.func。std::mem_fn可以帮助我们实现这个需求，本文探讨一下std::mem_fn的实现原理，并实现了一套my_mem_fn</p><span id="more"></span><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> ReturnType, <span class="hljs-keyword">typename</span> ClassType&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">mem_func_call_wrapper</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">ReturnType</span> <span class="hljs-params">(ClassType::*member_ptr)</span><span class="hljs-params">()</span></span>;<br>    member_ptr mem_ptr;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ReturnType <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(ClassType &amp;obj)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> (obj.*mem_ptr)();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">mem_func_call_wrapper</span><span class="hljs-params">(member_ptr mem_ptr)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>-&gt;mem_ptr = mem_ptr;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>这段代码定义了一个包装模板类，模板有两个参数，第1个参数表示包装的类成员函数的返回值类型，第二个参数表示成员函数所属的类类型</p><p>typedef ReturnType (ClassType::*member_ptr)();定义了一个类成员函数指针类型，ClassType::限定符表示这个指针指向的函数属于ClassType类</p><p>return (obj.*mem_ptr)(); 调用mem_ptr。这有一个解引用运算符，这也是类成员函数指针与普通的函数指针的差异性</p><p>我们可以调用这个wrapper类</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-built_in">int</span> main<span class="hljs-literal">()</span> &#123;<br>    A a;<br>    a.x = <span class="hljs-number">10</span>;<br>    A b;<br>    b.x = <span class="hljs-number">30</span>;<br>    mem_func_call_wrapper wrapper<span class="hljs-constructor">_a(&amp;A::<span class="hljs-params">func</span>)</span>;<br>    wrapper<span class="hljs-constructor">_a(<span class="hljs-params">a</span>)</span>;<br>    wrapper<span class="hljs-constructor">_a(<span class="hljs-params">b</span>)</span>;<br>    return <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">x</span>: <span class="hljs-number">10</span><br><span class="hljs-attribute">x</span>: <span class="hljs-number">30</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>开发</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Modern C++</title>
    <link href="/2022/08/23/Modern_C++/"/>
    <url>/2022/08/23/Modern_C++/</url>
    
    <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>本文来源于我的《Accelerated C++》学习笔记，但这本书并不包含现代C++（C++11以后的C++标准）。而后通过查阅零散资料以及《C++ Primer Plus 6th》补充了现代C++的部分。通过阅读本文，读者可以快速入门现代C++<br>目标人群画像</p><ol><li>学习过C语言</li><li>学习过Java等语言，了解Java 面向对象与泛型编程</li></ol><span id="more"></span><h3 id="STL容器的使用"><a href="#STL容器的使用" class="headerlink" title="STL容器的使用"></a>STL容器的使用</h3><h3 id="algorithm库算法的使用"><a href="#algorithm库算法的使用" class="headerlink" title="algorithm库算法的使用"></a>algorithm库算法的使用</h3><h3 id="泛型函数"><a href="#泛型函数" class="headerlink" title="泛型函数"></a>泛型函数</h3><h4 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h4><h4 id="split函数实现"><a href="#split函数实现" class="headerlink" title="split函数实现"></a>split函数实现</h4><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">template&lt;<span class="hljs-keyword">class</span> <span class="hljs-symbol">Out</span>&gt;<br><span class="hljs-symbol">void</span> <span class="hljs-symbol">split</span>(<span class="hljs-symbol">const</span> <span class="hljs-symbol">string</span> &amp;<span class="hljs-symbol">str, <span class="hljs-symbol">const</span></span> <span class="hljs-symbol">string</span> &amp;<span class="hljs-symbol">s, <span class="hljs-symbol">Out</span></span> <span class="hljs-symbol">out</span>) &#123;<br>    <span class="hljs-built_in">string</span>::size_type pos_start = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">string</span>::size_type pos_end = str.find(s);<br>    <span class="hljs-keyword">while</span> (pos_end != <span class="hljs-built_in">string</span>::npos) &#123;<br>        *<span class="hljs-keyword">out</span>++ = str.substr(pos_start, pos_end - pos_start);<br>        pos_start = pos_end + s.length();<br>        pos_end = str.find(s, pos_start);<br>    &#125;<br>    *<span class="hljs-keyword">out</span> = str.substr(pos_start);<br>&#125;<br></code></pre></td></tr></table></figure><p>Output</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-built_in">string</span> s1 = <span class="hljs-string">&quot;192..168..1..01&quot;</span>;<br>vector&lt;<span class="hljs-built_in">string</span>&gt; s;<br>split(s1, <span class="hljs-string">&quot;..&quot;</span>, back<span class="hljs-constructor">_inserter(<span class="hljs-params">s</span>)</span>);<br>copy(s.<span class="hljs-keyword">begin</span><span class="hljs-literal">()</span>, s.<span class="hljs-keyword">end</span><span class="hljs-literal">()</span>, ostream_iterator&lt;<span class="hljs-built_in">string</span>&gt;(cout, <span class="hljs-string">&quot; &quot;</span>));<br><br><span class="hljs-number">192</span> <span class="hljs-number">168</span> <span class="hljs-number">1</span> <span class="hljs-number">01</span><br></code></pre></td></tr></table></figure><h3 id="move与copy构造器"><a href="#move与copy构造器" class="headerlink" title="move与copy构造器"></a>move与copy构造器</h3><h3 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h3><h3 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h3><h3 id="友元函数重载二元运算符"><a href="#友元函数重载二元运算符" class="headerlink" title="友元函数重载二元运算符"></a>友元函数重载二元运算符</h3><h3 id="运算符重载实现迭代器"><a href="#运算符重载实现迭代器" class="headerlink" title="运算符重载实现迭代器"></a>运算符重载实现迭代器</h3><h3 id="xxx-pointer-cast"><a href="#xxx-pointer-cast" class="headerlink" title="xxx_pointer_cast"></a>xxx_pointer_cast</h3><h3 id="xxx-cast"><a href="#xxx-cast" class="headerlink" title="xxx_cast"></a>xxx_cast</h3><h3 id="decltype（C-11引入）"><a href="#decltype（C-11引入）" class="headerlink" title="decltype（C++11引入）"></a>decltype（C++11引入）</h3><p>decltype关键字可以获取到某一实体或某一表达式的参数类型。比如</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs r">template<span class="hljs-operator">&lt;</span>typename <span class="hljs-built_in">T</span><span class="hljs-operator">&gt;</span><br><span class="hljs-built_in">T</span> add<span class="hljs-punctuation">(</span><span class="hljs-built_in">T</span> a<span class="hljs-punctuation">,</span> <span class="hljs-built_in">T</span> b<span class="hljs-punctuation">)</span> <span class="hljs-punctuation">&#123;</span><br>    decltype<span class="hljs-punctuation">(</span>a<span class="hljs-punctuation">)</span> <span class="hljs-built_in">c</span>;<br>    <span class="hljs-built_in">c</span> <span class="hljs-operator">=</span> a <span class="hljs-operator">+</span> b;<br>    <span class="hljs-built_in">return</span> <span class="hljs-built_in">c</span>;<br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h3 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h3><p>lambda表达式的一般格式如下</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs smali">[ capture clause ] (parameters) -&gt;<span class="hljs-built_in"> return-type </span> <br>&#123;   <br>   definition of method   <br>&#125; <br></code></pre></td></tr></table></figure><p>capture clause表达式可以捕获到的当前作用域的外部变量。lambda表达式可以看成是一个隐藏名字的函数，假设我们有一个函数f1，f1里调用了一个lambda表达式，即一个隐藏名字的函数f2，f2与f1处在不同的作用域中，f2本来是不可以使用f1中的局部变量的，但是capture clause可以做到这一点，在这个例子中，就是f2捕获了f1作用域中的局部变量。捕获有两种类型，一种是按值捕获，也就是调用被捕获变量的复制构造器拷贝一份，把拷贝结果传递给lambda表达式，另一种是按引用捕获，也就是直接把被捕获变量的引用传递给lambda表达式<br>按引用捕获</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> x = <span class="hljs-number">5</span>;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Old x: &quot;</span> &lt;&lt; x &lt;&lt; endl;<br>    <span class="hljs-function">thread <span class="hljs-title">th1</span><span class="hljs-params">([&amp;x] &#123;x = <span class="hljs-number">10</span>;&#125;)</span></span>;<br>    th1.<span class="hljs-built_in">join</span>();<br>    cout &lt;&lt; <span class="hljs-string">&quot;New x: &quot;</span> &lt;&lt; x &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Old</span> x: <span class="hljs-number">5</span><br><span class="hljs-attribute">New</span> x: <span class="hljs-number">10</span><br></code></pre></td></tr></table></figure><p>按值捕获</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">obj1</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    obj1() &#123; &#125;<br>    obj1(<span class="hljs-keyword">const</span> obj1 &amp;o) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;OBJ1 Copy Constructor&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">main</span>()</span> &#123;<br>    obj1 obj;<br>    <span class="hljs-comment">// cout &lt;&lt; &quot;Old x: &quot; &lt;&lt; x &lt;&lt; endl;</span><br>    <span class="hljs-function">thread <span class="hljs-title">th1</span>(<span class="hljs-params">[obj] &#123;</span></span><br><span class="hljs-params"><span class="hljs-function"></span></span><br><span class="hljs-params"><span class="hljs-function">    &#125;</span>)</span>;<br>    th1.<span class="hljs-keyword">join</span>();<br>    <span class="hljs-comment">// cout &lt;&lt; &quot;New x: &quot; &lt;&lt; x &lt;&lt; endl;</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs oxygene">OBJ1 <span class="hljs-keyword">Copy</span> <span class="hljs-keyword">Constructor</span><br><span class="hljs-title function_">OBJ1</span> <span class="hljs-title function_">Copy</span> <span class="hljs-title function_">Constructor</span><br></code></pre></td></tr></table></figure><h3 id="C-14引入的泛型表达式"><a href="#C-14引入的泛型表达式" class="headerlink" title="C++14引入的泛型表达式"></a>C++14引入的泛型表达式</h3><p>考虑这样一种情况，如果我们的lambda表达式要支持泛型，比如stl中的sort实现，C++14提供了一种更优雅的实现，通过auto关键字，如下所示，假设i, j变量对应的类型重载了&gt;运算符。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">sort</span>(container.<span class="hljs-built_in">begin</span>(), container.<span class="hljs-built_in">end</span>(), <br>[](<span class="hljs-keyword">auto</span> i, <span class="hljs-keyword">auto</span> j) -&gt; <span class="hljs-type">bool</span> &#123; <span class="hljs-keyword">return</span> i &gt; j; &#125;<br></code></pre></td></tr></table></figure><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol><li><a href="https://www.cprogramming.com/c++11/rvalue-references-and-move-semantics-in-c++11.html">Move semantics and rvalue references in C++11</a></li><li><a href="https://en.cppreference.com/w/cpp/language/decltype">Decltype</a></li><li><a href="https://www.geeksforgeeks.org/generalized-lambda-expressions-c14/">C++14引入的泛型lambda表达式</a></li><li><a href="https://www.geeksforgeeks.org/lambda-expression-in-c/">lambda表达式</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>默认分类</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>CMake笔记</title>
    <link href="/2022/08/18/CMake%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/08/18/CMake%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p>因为不频繁用C/C++开发项目，所以，用几次CMake就得学几次CMake……为了节省时间，写篇文章记录一下学习过程，作为自己日后翻阅的资料</p><span id="more"></span><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>CMake中，可以指定生成binary, library等, 这些生成对象被称为target，通过调用add_library, add_binary命令来生成这些target。生成target的时候，我们可以通过target_include_direcories为target_link_libraries命令指定头文件目录和需要一起连接的.o文件</p><p>一个CMakeLists.txt对应一个project，通过add_subdirectory命令引入其它project作为子project。相应的，这个过程会出现一个top-level project的概念，也就是最顶层项目</p><p>CMake类似一种脚本语言，支持函数调用，定义变量，流程转移指令，基于这些，可以完成复杂的构建任务</p><h3 id="生成可执行文件和静态库"><a href="#生成可执行文件和静态库" class="headerlink" title="生成可执行文件和静态库"></a>生成可执行文件和静态库</h3><p>CMake脚本如下</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-built_in">cmake_minimum_required</span>(VERSION <span class="hljs-number">3.22</span>)<br><span class="hljs-built_in">project</span>(hello_binary)<br><br><span class="hljs-built_in">set</span>(CMAKE_CXX_STANDARD <span class="hljs-number">11</span>)<br><br># 生成library<br><br><span class="hljs-built_in">add_library</span>(hello_library STATIC src/Hello.cpp)<br><br><span class="hljs-built_in">target_include_directories</span>(hello_library PUBLIC<br>        $&#123;PROJECT_SOURCE_DIR&#125;/include)<br><br><span class="hljs-built_in">target_compile_definitions</span>(hello_library)<br># 生成可执行文件<br><br><span class="hljs-built_in">add_executable</span>(hello_binary src/main.cpp)<br><br><span class="hljs-built_in">target_link_libraries</span>(hello_binary PRIVATE<br>        hello_library)<br></code></pre></td></tr></table></figure><p>目录结构以及源代码如下<br><img src="/images/2022/08/2646494562.png" alt="0.png"></p><p>cmake_minimum_required命令指出最低cmake版本要求</p><p>project命令定义了当前project名，project命令实际上还会生成一系列的变量，<strong>projectname</strong>_SOURCE_DIR与<strong>projectname</strong>_BINARY_DIR变量分别指向当前project的源代码根目录和产生文件根目录（也就是储存生成的target文件的目录）</p><p>add_library命令表示生成一个library类型target，第一个参数是target名，后面可以通过target名引用它，第二个参数STATIC表示生成的是静态库，DYNAMIC表示生成动态库。需要注意的是，Windows平台下面，生成动态库比Linux平台更麻烦，需要手工导出函数符号</p><p>target_include_directories命令设置这个target和依赖这个target的其它target的头文件搜索目录，第二个参数定义的就是设置类型，可以设置为PRIVATE INTERFACE PUBLIC三种类型，下面解释一下这三种类型</p><ul><li>PRIVATE类型：只在生成这个target时有效</li><li>PUBLIC类型：不仅在生成这个target时有效，还会被传递给所有依赖这个target的其它target</li><li>INTERFACE类型：在生成这个target时无效，但是会被传递给所有依赖这个target的其它target<br>在本例中，由于我们生成的library中包含一个add函数，在binary中要调用这个函数，所以只能设置为PUBLIC类型，因为library要使用头文件，依赖它的binary也要使用头文件</li></ul><p>add_executable命令表示生成一个binary类型target，与add_library命令基本相同</p><p>target_link_libraries命令设置这个编译这个target的时候需要链接哪些.o文件。设置类型仍然有PRIVATE INTERFACE PUBLIC三种，而且与target_include_directories的三种类型含义一样<br>举个例子，比方说，我们有水果库，水果库有尺寸和价格两个函数，还有一个苹果库，苹果库有吃苹果一个函数，还有一个名为小红的可执行文件，她链接了苹果库。如果苹果库PRIVATE连接水果库，那么苹果库可以调用水果库里的尺寸和价格函数，但是小红只能调用苹果库的吃苹果（非INTERFACE链接苹果库情况下），不能调用水果库的尺寸和价格；如果苹果库INTERFACE链接水果库，那么苹果库不可以调用水果库里的函数，但是小红却可以调用水果库里的函数；如果苹果库PUBLIC链接水果库，那么苹果库和小红都能调用水果库里的函数</p><p>可以调用add_library或者add_binary为已有target设置别名，后面就可以通过别名引用这个target了<br>add_library(boost::filesystem ALIAS hello_library)，boost::filesystem就是hello_library的别名，尽可能结构化地命名target，比如这个命令就表示filesystem是boost库下的一个子模块，非常清晰易读</p><h3 id="多project"><a href="#多project" class="headerlink" title="多project"></a>多project</h3><p>还记得我们刚刚讲了一个包含苹果库，水果库，小红的那个例子吗，我们正好用这个例子来说明一下多project应该怎样组织，以及验证一下我们关于INTERFACE PRIVATE PUBLIC的说法<br>整个项目的目录结构如下。有3个子目录，分别对应3个子项目。共有4个CMakeLists.txt，分别对应3个子项目以及一个顶层项目<br><img src="/images/2022/08/377969474.png" alt="1.png"></p><p>顶层项目的CMakeLists.txt内容如下</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">cmake_minimum_required</span><span class="hljs-params">(VERSION <span class="hljs-number">3.22</span>)</span></span><br><span class="hljs-function"><span class="hljs-title">project</span><span class="hljs-params">(hello_binary)</span></span><br><br><span class="hljs-function"><span class="hljs-title">add_subdirectory</span><span class="hljs-params">(fruit)</span></span><br><span class="hljs-function"><span class="hljs-title">add_subdirectory</span><span class="hljs-params">(xiaohong)</span></span><br><span class="hljs-function"><span class="hljs-title">add_subdirectory</span><span class="hljs-params">(apple)</span></span><br></code></pre></td></tr></table></figure><p>apple库的CMakeLists.txt内容如下。我们添加了一个名为${PROJECT_NAME}的target，并为它设置了lib::apple的别名。${PROJECT_NAME}表示当前项目的名字，${PROJECT_SOURCE_DIR}表示当前项目的源代码根目录。我个人建议在当前项目的CMakeLists.txt中使用${PROJECT_NAME}引用target，但在其它项目的CMakeLists.txt中使用别名引用其它项目的target</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">project</span>(apple)<br><br><span class="hljs-keyword">add_library</span>(<span class="hljs-variable">$&#123;PROJECT_NAME&#125;</span> STATIC <span class="hljs-variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/src/apple.cpp)<br><span class="hljs-keyword">add_library</span>(lib::apple ALIAS <span class="hljs-variable">$&#123;PROJECT_NAME&#125;</span>)<br><br><span class="hljs-keyword">target_include_directories</span>(<span class="hljs-variable">$&#123;PROJECT_NAME&#125;</span><br>        PUBLIC <span class="hljs-variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/<span class="hljs-keyword">include</span>)<br><br><span class="hljs-comment"># 链接fruit库</span><br><span class="hljs-keyword">target_link_libraries</span>(<span class="hljs-variable">$&#123;PROJECT_NAME&#125;</span><br>        INTERFACE lib::fruit)<br></code></pre></td></tr></table></figure><p>有用的变量列表如下，从文献<a href="/images/2022/08/2646494562.png">1</a>中摘录的<br><img src="/images/2022/08/2962683274.png" alt="2.png"></p><p>xiaohong的CMakeLists.txt内容如下，注意我们在这只链接了apple库</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">cmake_minimum_required</span><span class="hljs-params">(VERSION <span class="hljs-number">3.22</span>)</span></span><br><span class="hljs-function"><span class="hljs-title">project</span><span class="hljs-params">(xiaohong)</span></span><br><br><span class="hljs-function"><span class="hljs-title">set</span><span class="hljs-params">(CMAKE_CXX_STANDARD <span class="hljs-number">11</span>)</span></span><br><br><span class="hljs-function"><span class="hljs-title">add_executable</span><span class="hljs-params">($&#123;PROJECT_NAME&#125; $&#123;PROJECT_SOURCE_DIR&#125;/main.cpp)</span></span><br><span class="hljs-function"><span class="hljs-title">target_link_libraries</span><span class="hljs-params">($&#123;PROJECT_NAME&#125; PUBLIC lib::apple)</span></span><br></code></pre></td></tr></table></figure><p>xiaohong的main.cpp内容如下，其中调用了apple与fruit库的函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;apple.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;fruit.h&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> </span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;fruit size %d, price %d\n&quot;</span>, <span class="hljs-built_in">size</span>(), <span class="hljs-built_in">price</span>());<br>    <span class="hljs-built_in">eat_apple</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>当我们修改apple库链接fruit库的链接类型为INTERFACE与PUBLIC时，都能正常通过编译运行。而当我们修改为PRIVATE链接时，就会FAIL，如下<br><img src="/images/2022/08/3195607936.png2683274.png" alt="3.png"></p><p>这个项目传到github上了，<a href="https://github.com/DrShabulaji/cmake_subject/tree/master">cmake_subject</a></p><h3 id="集成GoogleTest"><a href="#集成GoogleTest" class="headerlink" title="集成GoogleTest"></a>集成GoogleTest</h3><p>大二上学期的软工导论里有讲到敏捷开发，其中有一条编程原则是测试驱动开发。我过去的开发流程太朴素了，还停留在上世纪……借着折腾CMake的机会来试用一下GTest</p><p>CMake提供的CTest工具可以执行<strong>make test</strong>命令，可以将GTest测试框架集成进来。在CTest中，每一个单元测试都是一个可执行文件，执行它们就是执行测试</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">3.22</span>)<br><span class="hljs-keyword">project</span>(google_test)<br><br><span class="hljs-keyword">set</span>(CMAKE_CXX_STANDARD <span class="hljs-number">14</span>)<br><br><span class="hljs-keyword">add_library</span>(<span class="hljs-variable">$&#123;PROJECT_NAME&#125;</span> main.cpp)<br><br><span class="hljs-comment">#####################################</span><br><span class="hljs-comment"># add google test</span><br><span class="hljs-keyword">include</span>(FetchContent)<br>FetchContent_Declare(<br>        googletest<br>        GIT_REPOSITORY https://github.com/google/googletest.git<br>        GIT_TAG release-<span class="hljs-number">1.12</span>.<span class="hljs-number">1</span><br>)<br><span class="hljs-comment"># For Windows: Prevent overriding the parent project&#x27;s compiler/linker settings</span><br><span class="hljs-keyword">set</span>(gtest_force_shared_crt <span class="hljs-keyword">ON</span> CACHE BOOL <span class="hljs-string">&quot;&quot;</span> FORCE)<br>FetchContent_MakeAvailable(googletest)<br><br><span class="hljs-comment">#####################################</span><br><span class="hljs-comment"># Unit tests</span><br><br><span class="hljs-comment">#enable CTest testing</span><br><span class="hljs-keyword">enable_testing</span>()<br><br><span class="hljs-comment"># INCLUDE(GoogleTest)</span><br><br><span class="hljs-comment"># Add a testing executable</span><br><span class="hljs-keyword">add_executable</span>(unit_tests unit_tests.cpp)<br><br><span class="hljs-keyword">target_link_libraries</span>(unit_tests<br>        <span class="hljs-variable">$&#123;PROJECT_NAME&#125;</span><br>        GTest::gtest_main)<br><br><span class="hljs-keyword">add_test</span>(test_all unit_tests)<br></code></pre></td></tr></table></figure><p>FetchContent_MakeAvailable命令安装GoogleTest包，由CMake管理第3方包其实还算方便，但是坑爹的就是各种管理方式不统一……</p><p>enable_testing开启单元测试</p><p>add_executable把单元测试源文件编译为可执行文件</p><p>target_link_libraries, 把待测试的模块和GTest链接进入单元测试target</p><p>add_test 把编译出的单元测试target加入一个test中</p><p>unit_tests.cpp源文件内容如下</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">#<span class="hljs-keyword">include</span> &lt;gtest/gtest.h&gt;<br>#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;main.h&quot;</span><br><br><span class="hljs-constructor">TEST(HelloTest, PositiveAndNegative)</span> &#123;<br>    <span class="hljs-constructor">EXPECT_EQ(<span class="hljs-params">add</span>(12, 23)</span>, <span class="hljs-number">35</span>);<br>    <span class="hljs-constructor">EXPECT_EQ(<span class="hljs-params">add</span>(-1, 13)</span>, <span class="hljs-number">12</span>);<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="日常trick"><a href="#日常trick" class="headerlink" title="日常trick"></a>日常trick</h3><h4 id="linux下多线程"><a href="#linux下多线程" class="headerlink" title="linux下多线程"></a>linux下多线程</h4><p>在linux环境下使用多线程需要在连接时指定-pthread选项，使用cmake构建系统时，可以使用target_link_options实现这个过程</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">if</span><span class="hljs-params">(UNIX)</span></span><br><span class="hljs-function"><span class="hljs-title">target_link_options</span><span class="hljs-params">(classify_fuying PRIVATE -pthread)</span></span><br><span class="hljs-function"><span class="hljs-title">endif</span><span class="hljs-params">()</span></span><br></code></pre></td></tr></table></figure><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol><li><a href="https://leimao.github.io/blog/CMake-Public-Private-Interface/">cmake中private interface public三种关键字的辨析</a></li><li><a href="https://github.com/ttroy50/cmake-examples">cmake example</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>开发</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Powershell permanent alias</title>
    <link href="/2022/08/17/Powershell_permanent_alias/"/>
    <url>/2022/08/17/Powershell_permanent_alias/</url>
    
    <content type="html"><![CDATA[<p>最近一直要用到pin，发现可以新建一个别名简化流程</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-built_in">New</span>-<span class="hljs-keyword">Alias</span> -<span class="hljs-type">Name</span> pin -<span class="hljs-keyword">Value</span> D:\Projects\pin\pin.exe<br></code></pre></td></tr></table></figure><p>完成后，输入pin即可。但是坑爹的是重启一个shell窗口这个别名就失效了</p><p>参考<a href="/images/2022/08/408243473.png">1</a>，在C:\Users\user_name\Documents目录下新建一个profile.ps1，然后把新建别名的指令写入它，powershell在以user_name用户启动时，会自动执行其中的指令</p><p>你以为到这里就结束了吗？naive…</p><p>有个大坑，在某个目录下面，右键，在terminal中打开，弹出的powershell窗口又不存在pin别名了</p><p>查找资料[2]发现，powershell有6个不同的路径设置profile.ps1，感受一下，分别对应不同的用户与不同的目录启动。把profile.ps1复制到$PsHome目录下即可</p><p><img src="/images/2022/08/408243473.png" alt="0.png"></p><p><a href="/images/2022/08/408243473.png">1</a><a href="https://stackoverflow.com/questions/24914589/how-to-create-permanent-powershell-aliases">https://stackoverflow.com/questions/24914589/how-to-create-permanent-powershell-aliases</a><br>[2]<a href="https://web.archive.org/web/20121105003839/http://blogs.technet.com/b/heyscriptingguy/archive/2012/05/21/understanding-the-six-powershell-profiles.aspx">https://web.archive.org/web/20121105003839/http://blogs.technet.com/b/heyscriptingguy/archive/2012/05/21/understanding-the-six-powershell-profiles.aspx</a></p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>radare2小记</title>
    <link href="/2022/08/02/radare2%E5%B0%8F%E8%AE%B0/"/>
    <url>/2022/08/02/radare2%E5%B0%8F%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h3 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h3><p>最近需要一些轻量级的分析框架提取大量信息，试用了IDA和Ghidra的Batch mode后，我的内心只有一个想法：卧槽这都啥玩意啊。IDA的Batch mode下，生成一个idb文件所需时间是gui模式的数十倍。试用了radare2后，真香</p><span id="more"></span><h3 id="radare2命令"><a href="#radare2命令" class="headerlink" title="radare2命令"></a>radare2命令</h3><p>r2有cui与gui模式，gui需要下载cutter。r2的cui交互模式与vim编辑器类似，而且r2是self-documentated的，对于不清楚的命令，可以在后面加?，打印出帮助，如下图所示。其中方括号内部的地址，表示当前地址<br><img src="/images/2022/08/4111987883.png" alt="0.png"></p><p>r2的cui交互是可以与shell互通的，比如说i | grep nx，表示把命令i的输出通过管道传递给grep；iz &gt; 1.txt，表示把命令iz的输出写入1.txt</p><h4 id="打开文件"><a href="#打开文件" class="headerlink" title="打开文件"></a>打开文件</h4><p>r2 filename</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">r2 <span class="hljs-regexp">/bin/</span>ls<br></code></pre></td></tr></table></figure><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">pd <span class="hljs-number">100</span> @main<br>pd - <span class="hljs-built_in">print</span> disasm<br>打印符号main处的<span class="hljs-number">100</span>条反汇编指令<br></code></pre></td></tr></table></figure><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">i</span><br>显示信息<br><br><span class="hljs-title">iz</span><br>显示<span class="hljs-class"><span class="hljs-keyword">data</span>区块中的所有字符串</span><br></code></pre></td></tr></table></figure><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">axq</span><br>打印出所有交叉引用信息<br></code></pre></td></tr></table></figure><h3 id="python与radare2交互"><a href="#python与radare2交互" class="headerlink" title="python与radare2交互"></a>python与radare2交互</h3><p>安装r2pipe包后，可以通过管道与r2交互。注意在windows下时，需要将&lt;r2安装目录&gt;/bin添加到环境变量Path中</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs scss">def <span class="hljs-built_in">get_str_and_ref</span>(file):<br>    file_name = MALWARE_SET + <span class="hljs-string">&quot;\\&quot;</span> + file<br>    r2 = r2pipe.<span class="hljs-built_in">open</span>(file_name, [<span class="hljs-string">&quot;-e bin.cache=true&quot;</span>])<br>    r2.<span class="hljs-built_in">cmd</span>(<span class="hljs-string">&quot;aa&quot;</span>)<br>    str_raw = r2.<span class="hljs-built_in">cmd</span>(<span class="hljs-string">&quot;iz&quot;</span>)<br>    <span class="hljs-built_in">print</span>(str_raw)<br>    ref_raw = r2.<span class="hljs-built_in">cmd</span>(<span class="hljs-string">&quot;axq&quot;</span>)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>pwnable bottle系列部分WP</title>
    <link href="/2022/07/29/pwnable_bottle%E7%B3%BB%E5%88%97WP/"/>
    <url>/2022/07/29/pwnable_bottle%E7%B3%BB%E5%88%97WP/</url>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>最近在想社团招新培训的事，于是找了一些入门安全学习资料，在这个过程中还是有一些收获的，写篇文章记录一下</p><p>pwnable.kr</p><h3 id="cmd1"><a href="#cmd1" class="headerlink" title="cmd1"></a>cmd1</h3><p><img src="/images/2022/07/3054445868.png" alt="0.png"></p><p>显然，我们要通过cmd1执行cat flag</p><p>这道题有两个坑点</p><ol><li><p>修改了PATH环境变量为/thankyouverymuch，所以我们必须使用绝对路径引用cat和flag</p></li><li><p>有一个过滤函数，会过滤掉包含’sh’, ‘flag’, ‘tmp’的命令</p></li></ol><p>如果不过滤tmp的话，我们可以在tmp里开一个目录A，再在/tmp/A里面新建一个软链接B指向/home/cmd1/flag，再通过cat /tmp/A/B就可以读取flag</p><p>这里有个传参的技巧要注意一下，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">NAME=1234<br><span class="hljs-meta prompt_"># </span><span class="language-bash">./cmd1 <span class="hljs-string">&quot;<span class="hljs-subst">$(NAME)</span>&quot;</span></span><br>ARGV[1] = 1234 <br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">./cmd1 <span class="hljs-string">&#x27;$(NAME)&#x27;</span></span><br>ARGV[1] = $(NAME)<br></code></pre></td></tr></table></figure><p>也就是说，通过’’包裹的参数，不会先经过shell处理，直接传给了程序；通过””包裹的参数，会先经过shell处理再传给程序</p><p>那么解就显而易见了，我们通过<code>echo f</code>规避flag检查</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-string">./cmd1</span> &#x27;<span class="hljs-string">/bin/cat</span> <span class="hljs-string">/home/cmd1/</span>`<span class="hljs-keyword">echo</span> f`lag&#x27;<br><br>mommy now I get what PATH environment is for :)<br></code></pre></td></tr></table></figure><span id="more"></span><h3 id="cmd2"><a href="#cmd2" class="headerlink" title="cmd2"></a>cmd2</h3><p><img src="/images/2022/07/3557561940.png" alt="1.png"></p><p>新增加了一些过滤规则，过滤掉/, `</p><p>通过查找WP，知道了shell中另一种执行命令的方式**$(command)**，在网上搜索了下，好像Win的PowerShell也支持这种方式</p><p>而后使用<strong>printf “%b” “\x2f”<strong>输出/，使用</strong>printf “%s %s” fl ag</strong>或者<strong>echo f; echo lag</strong>绕过对flag的检测即可</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-constructor">$(<span class="hljs-params">printf</span> <span class="hljs-string">&quot;%bbin%bcat %s&quot;</span> <span class="hljs-string">&quot;\57&quot;</span> <span class="hljs-string">&quot;\57&quot;</span> <span class="hljs-string">&quot;fl&quot;</span>; <span class="hljs-params">echo</span> <span class="hljs-params">ag</span>)</span><br><br>FuN_w1th_5h3ll_v4riabl3s_haha<br></code></pre></td></tr></table></figure><p>通过查阅WP，绕过flag检测还有一些技巧，比如使用通配符，fla*</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>MIPS汇编入门</title>
    <link href="/2022/07/25/MIPS%E6%B1%87%E7%BC%96%E5%85%A5%E9%97%A8/"/>
    <url>/2022/07/25/MIPS%E6%B1%87%E7%BC%96%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>IoT Malware的特点就是跨架构，目前常见的就有x86, AMD64, Arm, MIPS, PowerPC等架构。很多时候看IDA的反编译结果已经不足以完成分析工作了，需要直接进入汇编层次的对抗。本文记录一下MIPS架构汇编的学习</p><span id="more"></span><h3 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h3><h4 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h4><p><img src="/images/2022/07/3480031595.png" alt="0.png"><br>图片来源资料<a href="/images/2022/07/3480031595.png">1</a></p><p>第1列与第2列是寄存器的两种命名方式，推荐使用第2列的命名方式，因为更为清晰直白</p><p>其中r0寄存器永远为1，r1寄存器是临时寄存器，一般而言，r0与r1寄存器通常会被联合使用以实现一些伪指令，例如li, la指令</p><p>v0-v1寄存器存放函数返回值，a0-a3存放函数参数</p><p>t0-t9寄存器是临时寄存器，在调用callee前，必须由caller保存，callee可以覆写它们</p><p>s0-s7寄存器是安全函数变量（safe function variable），callee不能覆写它们</p><p>k0, k1寄存器由内核使用</p><p>gp寄存器是全局指针，这与MIPS的编码特性有关，这里先简单提一下。MIPS是RISC架构，每条指令的长度固定为4字节，那么编码一条内存访问指令时，受限于指令长度，内存地址操作数不可能超过32位。如果要访问整个内存地址空间，就需要使用偏移访问的方式来完成，gp寄存器就是实现偏移访问的一种方案</p><p>sp寄存器是栈寄存器，fp寄存器是栈帧寄存器，类似于x86架构中的esp与ebp</p><p>ra寄存器是保存返回地址。x86架构下，返回地址被保存在栈上。由于返回地址被保存在寄存器中，当caller调用callee时，就需要备份ra寄存器</p><h4 id="指令集"><a href="#指令集" class="headerlink" title="指令集"></a>指令集</h4><table border="1" cellspacing="0"> <tbody><tr><td>Opcode</td><td>Name</td><td>Action</td><td colspan="6">Opcode bitfields</td></tr> <tr><td colspan="9"><b>Arithmetic Logic Unit</b></td></tr> <tr><td>ADD rd,rs,rt</td><td>Add</td><td>rd=rs+rt</td>   <td>000000</td><td>rs</td><td>rt</td><td>rd</td><td>00000</td><td>100000</td></tr> <tr><td>ADDI rt,rs,imm</td><td>Add Immediate</td><td>rt=rs+imm</td>   <td>001000</td><td>rs</td><td>rt</td><td colspan="3">imm</td></tr> <tr><td>ADDIU rt,rs,imm</td><td>Add Immediate Unsigned</td><td>rt=rs+imm</td>   <td>001001</td><td>rs</td><td>rt</td><td colspan="3">imm</td></tr> <tr><td>ADDU rd,rs,rt</td><td>Add Unsigned</td><td>rd=rs+rt</td>   <td>000000</td><td>rs</td><td>rt</td><td>rd</td><td>00000</td><td>100001</td></tr> <tr><td>AND rd,rs,rt</td><td>And</td><td>rd=rs&amp;rt</td>   <td>000000</td><td>rs</td><td>rt</td><td>rd</td><td>00000</td><td>100100</td></tr> <tr><td>ANDI rt,rs,imm</td><td>And Immediate</td><td>rt=rs&amp;imm</td>   <td>001100</td><td>rs</td><td>rt</td><td colspan="3">imm</td></tr> <tr><td>LUI rt,imm</td><td>Load Upper Immediate</td><td>rt=imm&lt;&lt;16</td>   <td>001111</td><td>rs</td><td>rt</td><td colspan="3">imm</td></tr> <tr><td>NOR rd,rs,rt</td><td>Nor</td><td>rd=~(rs|rt)</td>   <td>000000</td><td>rs</td><td>rt</td><td>rd</td><td>00000</td><td>100111</td></tr> <tr><td>OR rd,rs,rt</td><td>Or</td><td>rd=rs|rt</td>   <td>000000</td><td>rs</td><td>rt</td><td>rd</td><td>00000</td><td>100101</td></tr> <tr><td>ORI rt,rs,imm</td><td>Or Immediate</td><td>rt=rs|imm</td>   <td>001101</td><td>rs</td><td>rt</td><td colspan="3">imm</td></tr> <tr><td>SLT rd,rs,rt</td><td>Set On Less Than</td><td>rd=rs&lt;rt</td>   <td>000000</td><td>rs</td><td>rt</td><td>rd</td><td>00000</td><td>101010</td></tr> <tr><td>SLTI rt,rs,imm</td><td>Set On Less Than Immediate</td><td>rt=rs&lt;imm</td>   <td>001010</td><td>rs</td><td>rt</td><td colspan="3">imm</td></tr> <tr><td>SLTIU rt,rs,imm</td><td>Set On &lt; Immediate Unsigned</td><td>rt=rs&lt;imm</td>   <td>001011</td><td>rs</td><td>rt</td><td colspan="3">imm</td></tr> <tr><td>SLTU rd,rs,rt</td><td>Set On Less Than Unsigned</td><td>rd=rs&lt;rt</td>   <td>000000</td><td>rs</td><td>rt</td><td>rd</td><td>00000</td><td>101011</td></tr> <tr><td>SUB rd,rs,rt</td><td>Subtract</td><td>rd=rs-rt</td>   <td>000000</td><td>rs</td><td>rt</td><td>rd</td><td>00000</td><td>100010</td></tr> <tr><td>SUBU rd,rs,rt</td><td>Subtract Unsigned</td><td>rd=rs-rt</td>   <td>000000</td><td>rs</td><td>rt</td><td>rd</td><td>00000</td><td>100011</td></tr> <tr><td>XOR rd,rs,rt</td><td>Exclusive Or</td><td>rd=rs^rt</td>   <td>000000</td><td>rs</td><td>rt</td><td>rd</td><td>00000</td><td>100110</td></tr> <tr><td>XORI rt,rs,imm</td><td>Exclusive Or Immediate</td><td>rt=rs^imm</td>   <td>001110</td><td>rs</td><td>rt</td><td colspan="3">imm</td></tr>    <tr><td colspan="9"><b>Shifter</b></td></tr>    <tr><td>SLL rd,rt,sa</td><td>Shift Left Logical</td><td>rd=rt&lt;&lt;sa</td>   <td>000000</td><td>rs</td><td>rt</td><td>rd</td><td>sa</td><td>000000</td></tr> <tr><td>SLLV rd,rt,rs</td><td>Shift Left Logical Variable</td><td>rd=rt&lt;&lt;rs</td>   <td>000000</td><td>rs</td><td>rt</td><td>rd</td><td>00000</td><td>000100</td></tr> <tr><td>SRA rd,rt,sa</td><td>Shift Right Arithmetic</td><td>rd=rt&gt;&gt;sa</td>   <td>000000</td><td>00000</td><td>rt</td><td>rd</td><td>sa</td><td>000011</td></tr> <tr><td>SRAV rd,rt,rs</td><td>Shift Right Arithmetic Variable</td><td>rd=rt&gt;&gt;rs</td>   <td>000000</td><td>rs</td><td>rt</td><td>rd</td><td>00000</td><td>000111</td></tr> <tr><td>SRL rd,rt,sa</td><td>Shift Right Logical</td><td>rd=rt&gt;&gt;sa</td>   <td>000000</td><td>rs</td><td>rt</td><td>rd</td><td>sa</td><td>000010</td></tr> <tr><td>SRLV rd,rt,rs</td><td>Shift Right Logical Variable</td><td>rd=rt&gt;&gt;rs</td>   <td>000000</td><td>rs</td><td>rt</td><td>rd</td><td>00000</td><td>000110</td></tr>    <tr><td colspan="9"><b>Multiply</b></td></tr>    <tr><td>DIV rs,rt</td><td>Divide</td><td>HI=rs%rt; LO=rs/rt</td>   <td>000000</td><td>rs</td><td>rt</td><td colspan="2">0000000000</td><td>011010</td></tr> <tr><td>DIVU rs,rt</td><td>Divide Unsigned</td><td>HI=rs%rt; LO=rs/rt</td>   <td>000000</td><td>rs</td><td>rt</td><td colspan="2">0000000000</td><td>011011</td></tr> <tr><td>MFHI rd</td><td>Move From HI</td><td>rd=HI</td>   <td>000000</td><td colspan="2">0000000000</td><td>rd</td><td>00000</td><td>010000</td></tr> <tr><td>MFLO rd</td><td>Move From LO</td><td>rd=LO</td>   <td>000000</td><td colspan="2">0000000000</td><td>rd</td><td>00000</td><td>010010</td></tr> <tr><td>MTHI rs</td><td>Move To HI</td><td>HI=rs</td>   <td>000000</td><td>rs</td><td colspan="3">000000000000000</td><td>010001</td></tr> <tr><td>MTLO rs</td><td>Move To LO</td><td>LO=rs</td>   <td>000000</td><td>rs</td><td colspan="3">000000000000000</td><td>010011</td></tr> <tr><td>MULT rs,rt</td><td>Multiply</td><td>HI,LO=rs*rt</td>   <td>000000</td><td>rs</td><td>rt</td><td colspan="2">0000000000</td><td>011000</td></tr> <tr><td>MULTU rs,rt</td><td>Multiply Unsigned</td><td>HI,LO=rs*rt</td>   <td>000000</td><td>rs</td><td>rt</td><td colspan="2">0000000000</td><td>011001</td></tr> <tr><td colspan="9"><b>Branch</b></td></tr>   <tr><td>BEQ rs,rt,offset</td><td>Branch On Equal</td><td>if(rs==rt) pc+=offset*4</td>   <td>000100</td><td>rs</td><td>rt</td><td colspan="3">offset</td></tr> <tr><td>BGEZ rs,offset</td><td>Branch On &gt;= 0</td><td>if(rs&gt;=0) pc+=offset*4</td>   <td>000001</td><td>rs</td><td>00001</td><td colspan="3">offset</td></tr> <tr><td>BGEZAL rs,offset</td><td>Branch On &gt;= 0 And Link</td><td>r31=pc; if(rs&gt;=0) pc+=offset*4</td>   <td>000001</td><td>rs</td><td>10001</td><td colspan="3">offset</td></tr> <tr><td>BGTZ rs,offset</td><td>Branch On &gt; 0</td><td>if(rs&gt;0) pc+=offset*4</td>   <td>000111</td><td>rs</td><td>00000</td><td colspan="3">offset</td></tr> <tr><td>BLEZ rs,offset</td><td>Branch On </td><td>if(rs&lt;=0) pc+=offset*4</td>   <td>000110</td><td>rs</td><td>00000</td><td colspan="3">offset</td></tr> <tr><td>BLTZ rs,offset</td><td>Branch On &lt; 0</td><td>if(rs&lt;0) pc+=offset*4</td>   <td>000001</td><td>rs</td><td>00000</td><td colspan="3">offset</td></tr> <tr><td>BLTZAL rs,offset</td><td>Branch On &lt; 0 And Link</td><td>r31=pc; if(rs&lt;0) pc+=offset*4</td>   <td>000001</td><td>rs</td><td>10000</td><td colspan="3">offset</td></tr> <tr><td>BNE rs,rt,offset</td><td>Branch On Not Equal</td><td>if(rs!=rt) pc+=offset*4</td>   <td>000101</td><td>rs</td><td>rt</td><td colspan="3">offset</td></tr> <tr><td>BREAK</td><td>Breakpoint</td><td>epc=pc; pc=0x3c</td>   <td>000000</td><td colspan="4">code</td><td>001101</td></tr> <tr><td>J target</td><td>Jump</td><td>pc=pc_upper|(target&lt;&lt;2)</td>   <td>000010</td><td colspan="5">target</td></tr> <tr><td>JAL target</td><td>Jump And Link</td><td>r31=pc; pc=target&lt;&lt;2</td>   <td>000011</td><td colspan="5">target</td></tr> <tr><td>JALR rs</td><td>Jump And Link Register</td><td>rd=pc; pc=rs</td>   <td>000000</td><td>rs</td><td>00000</td><td>rd</td><td>00000</td><td>001001</td></tr> <tr><td>JR rs</td><td>Jump Register</td><td>pc=rs</td>   <td>000000</td><td>rs</td><td colspan="3">000000000000000</td><td>001000</td></tr> <tr><td>MFC0 rt,rd</td><td>Move From Coprocessor</td><td>rt=CPR[0,rd]</td>   <td>010000</td><td>00000</td><td>rt</td><td>rd</td><td colspan="2">00000000000</td></tr> <tr><td>MTC0 rt,rd</td><td>Move To Coprocessor</td><td>CPR[0,rd]=rt</td>   <td>010000</td><td>00100</td><td>rt</td><td>rd</td><td colspan="2">00000000000</td></tr> <tr><td>SYSCALL</td><td>System Call</td><td>epc=pc; pc=0x3c</td>   <td>000000</td><td colspan="4">00000000000000000000</td><td>001100</td></tr>    <tr><td colspan="9"><b>Memory Access</b></td></tr>    <tr><td>LB rt,offset(rs)</td><td>Load Byte</td><td>rt=*(char*)(offset+rs)</td>   <td>100000</td><td>rs</td><td>rt</td><td colspan="3">offset</td></tr> <tr><td>LBU rt,offset(rs)</td><td>Load Byte Unsigned</td><td>rt=*(Uchar*)(offset+rs)</td>   <td>100100</td><td>rs</td><td>rt</td><td colspan="3">offset</td></tr> <tr><td>LH rt,offset(rs)</td><td>Load Halfword</td><td>rt=*(short*)(offset+rs)</td>   <td>100001</td><td>rs</td><td>rt</td><td colspan="3">offset</td></tr> <tr><td>LBU rt,offset(rs)</td><td>Load Halfword Unsigned</td><td>rt=*(Ushort*)(offset+rs)</td>   <td>100101</td><td>rs</td><td>rt</td><td colspan="3">offset</td></tr> <tr><td>LW rt,offset(rs)</td><td>Load Word</td><td>rt=*(int*)(offset+rs)</td>   <td>100011</td><td>rs</td><td>rt</td><td colspan="3">offset</td></tr> <tr><td>SB rt,offset(rs)</td><td>Store Byte</td><td>*(char*)(offset+rs)=rt</td>   <td>101000</td><td>rs</td><td>rt</td><td colspan="3">offset</td></tr> <tr><td>SH rt,offset(rs)</td><td>Store Halfword</td><td>*(short*)(offset+rs)=rt</td>   <td>101001</td><td>rs</td><td>rt</td><td colspan="3">offset</td></tr> <tr><td>SW rt,offset(rs)</td><td>Store Word</td><td>*(int*)(offset+rs)=rt</td>   <td>101011</td><td>rs</td><td>rt</td><td colspan="3">offset</td></tr></tbody></table><p>表格来源于资料<a href="/images/2022/07/3480031595.png">1</a></p><h5 id="操作数长度"><a href="#操作数长度" class="headerlink" title="操作数长度"></a>操作数长度</h5><p>在MIPS汇编中，W(WORD)长度4字节，H(HALFWORD)长度2字节，B(Byte)长度1字节</p><p>表格的Opcode bitfields列详细说明了MIPS指令的编码方式。每条指令固定长度32位，前6位是opcode，剩余位用以编码操作数或对齐。列中，rs rt rd都代表寄存器，对应reg source, reg t(不知道，没想到是啥的缩写), reg dest。由于MIPS有32个寄存器，因此寄存器操作数的长度为5位</p><h5 id="跳转指令"><a href="#跳转指令" class="headerlink" title="跳转指令"></a>跳转指令</h5><p>B*系列指令是条件跳转指令，挑2条有代表性的如下</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs applescript">beq rs, rt, <span class="hljs-built_in">offset</span><br><span class="hljs-keyword">if</span> (rs==rt) pc += <span class="hljs-built_in">offset</span> * <span class="hljs-number">4</span><br><span class="hljs-number">000100</span> | rs | rt | <span class="hljs-built_in">offset</span><br><br>bgez rs,<span class="hljs-built_in">offset</span><br><span class="hljs-keyword">if</span> (rs&gt;=<span class="hljs-number">0</span>) pc += <span class="hljs-built_in">offset</span> * <span class="hljs-number">4</span><br><span class="hljs-number">000001</span> | rs | <span class="hljs-number">00001</span> | <span class="hljs-built_in">offset</span><br></code></pre></td></tr></table></figure><p>与x86架构一样，跳转指令的编码格式是通过PC（EIP）实现的，offset表示跳转目标与当前地址的偏移。注意那个offset * 4的操作，由于MIPS的指令长度是4字节，因此，每一条指令的起始地址都应该与4对齐，也就是说，offset字段储存的是偏移指令条数，而非偏移字节数</p><p>JR rs指令提供了寄存器寻址的跳转能力</p><h5 id="带保存返回地址的跳转（函数调用）指令"><a href="#带保存返回地址的跳转（函数调用）指令" class="headerlink" title="带保存返回地址的跳转（函数调用）指令"></a>带保存返回地址的跳转（函数调用）指令</h5><p>JAL与JALR指令与x86架构的call指令类似，它们保存返回地址到ra寄存器</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs abnf">JAL  target<br><span class="hljs-attribute">pc</span> <span class="hljs-operator">=</span> target &lt;&lt; <span class="hljs-number">2</span>，这与B*系列指令的offset字段类似<br><br>JALR rs<br><span class="hljs-attribute">pc</span> <span class="hljs-operator">=</span> rs<br></code></pre></td></tr></table></figure><h5 id="内存访问指令"><a href="#内存访问指令" class="headerlink" title="内存访问指令"></a>内存访问指令</h5><p>L<em>系列指令加载内存进入寄存器，S</em>系列指令写入内存进入寄存器</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs excel">LB rt,<span class="hljs-built_in">offset</span>(rs)<br>rt = *(<span class="hljs-built_in">char</span>*)(<span class="hljs-built_in">offset</span> + rs)<br><br>LBU rt,<span class="hljs-built_in">offset</span>(rs)<br>rt = *(Uchar*)(<span class="hljs-built_in">offset</span> + rs)<br><br><span class="hljs-built_in">offset</span>操作数的长度为<span class="hljs-number">16</span>位<br></code></pre></td></tr></table></figure><p>LB与LBU的区别主要在于寄存器的高位填充，由于MIPS寄存器都是32位的，因此读入BYTE与HALF-WORD时，必然要考虑高位填充的问题，后缀为U的指令高位填充0，无U后缀的指令高位填充1。而加载WORD时就没有这个问题，因此只有LW而无LWU指令</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs excel">SB rt,<span class="hljs-built_in">offset</span>(rs)<br>*(<span class="hljs-built_in">char</span>*)(<span class="hljs-built_in">offset</span> + rs) = rt<br><br><span class="hljs-built_in">offset</span>操作数长度也为<span class="hljs-number">16</span>位<br></code></pre></td></tr></table></figure><h5 id="算数运算"><a href="#算数运算" class="headerlink" title="算数运算"></a>算数运算</h5><p>后缀带I的指令表示参与运算的操作数可以有立即数，不带I的指令表示参与运算的操作数必须都是寄存器</p><p>注意LUI rt,imm指令，它的语义是rt = imm&lt;&lt;16。由于MIPS单条指令的长度固定为32位，我们没有办法编码出一条加载32位长度立即数进入寄存器的指令。因此提供LUI与ORI指令完成32位立即数加载</p><p>乘法与除法相关指令的运算结果保存在HI,LO寄存器中，可以通过MFHI/O与MTHI/O指令操纵HI,LO寄存器</p><h4 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h4><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-comment"># hello.s ... print &quot;Hello, MIPS&quot;</span><br><br>       <span class="hljs-meta">.data</span>          <span class="hljs-comment"># the data segment</span><br><span class="hljs-symbol">msg:</span>   .asciiz <span class="hljs-string">&quot;Hello, MIPS\n&quot;</span><br><br>       <span class="hljs-meta">.text</span>          <span class="hljs-comment"># the code segment</span><br>       .globl main<br><span class="hljs-symbol">main:</span>  <br>        la $<span class="hljs-built_in">a0</span>, msg   <span class="hljs-comment"># load the argument string</span><br>        li $<span class="hljs-built_in">v0</span>, <span class="hljs-number">4</span>     <span class="hljs-comment"># load the system call (print)</span><br>        <span class="hljs-keyword">syscall </span>      <span class="hljs-comment"># print the string</span><br>        <span class="hljs-keyword">jr </span>$<span class="hljs-built_in">ra</span>        <span class="hljs-comment"># return to caller (__start)</span><br></code></pre></td></tr></table></figure><p>来源于资料<a href="/images/2022/07/2156284401.png">2</a></p><p>这个例子其实很有意思，la与li指令是伪指令，在QtSpim模拟器下面，这两条伪指令对应的真实指令如下<br><img src="/images/2022/07/2156284401.png" alt="1.png"></p><p>由于msg的地址在0x10010000，注意低16位是0，所以使用lui $4, 0x1001指令就可以实现la $a0, msg伪指令</p><p>4的高16位很显然是0，所以使用ori $2, $0, 4指令就可以实现li $v0, 4。注意$0寄存器的值恒为0</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>1.<a href="https://opencores.org/projects/plasma/opcodes">MIPS汇编指令编码</a><br>2.<a href="https://www.cse.unsw.edu.au/~cs1521/18s2/notes/C/notes.html">CS1521, UNSW, MIPS汇编语言资料</a></p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>逆向</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>UPX静态脱壳</title>
    <link href="/2022/07/18/UPX%E9%9D%99%E6%80%81%E8%84%B1%E5%A3%B3/"/>
    <url>/2022/07/18/UPX%E9%9D%99%E6%80%81%E8%84%B1%E5%A3%B3/</url>
    
    <content type="html"><![CDATA[<h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><p>最近开始做恶意软件归因了，需要从蜜罐里面提取出大的样本集，部分样本是UPX加壳处理过的，需要脱壳处理。使用upx -d对样本进行处理，部分脱壳成功，部分失败。失败的部分是魔改了upx加壳后的信息，修复后即可进行脱壳处理</p><span id="more"></span><h3 id="UPX信息"><a href="#UPX信息" class="headerlink" title="UPX信息"></a>UPX信息</h3><h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><p>UPX的信息结构有b_info, l_info, p_info, 目前似乎只需要关注l_info与b_info。事实上，我只见到了两种类型的UPX信息修改</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">b_info</span> <span class="hljs-comment">// 12-byte header before each compressed block</span><br>&#123; <br><br><span class="hljs-type">uint32_t</span> sz_unc; <span class="hljs-comment">// uncompressed_size</span><br><span class="hljs-type">uint32_t</span> sz_cpr; <span class="hljs-comment">// compressed_size</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> b_method; <span class="hljs-comment">// compression algorithm</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> b_ftid; <span class="hljs-comment">// filter id</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> b_cto8; <span class="hljs-comment">// filter parameter</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> b_unused; <span class="hljs-comment">// unused</span><br><br>&#125;; <br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">l_info</span> <span class="hljs-comment">// 12-byte trailer in header for loader (offset 116)</span><br>&#123; <br><br><span class="hljs-type">uint32_t</span> l_checksum; <span class="hljs-comment">// checksum</span><br><span class="hljs-type">uint32_t</span> l_magic; <span class="hljs-comment">// UPX! magic [55 50 58 21]，必须为55 50 58 21</span><br><span class="hljs-type">uint16_t</span> l_lsize; <span class="hljs-comment">// loader size</span><br><span class="hljs-type">uint8_t</span> l_version; <span class="hljs-comment">// version info</span><br><span class="hljs-type">uint8_t</span> l_format; <span class="hljs-comment">// UPX format </span><br><br>&#125;; <br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">p_info</span> <span class="hljs-comment">// 12-byte packed program header follows stub loader</span><br>&#123; <br><br><span class="hljs-type">uint32_t</span> p_progid; <span class="hljs-comment">// program header id [00 00 00 00]，必须为0</span><br><span class="hljs-type">uint32_t</span> p_filesize; <span class="hljs-comment">// filesize [same as blocksize]</span><br><span class="hljs-type">uint32_t</span> p_blocksize; <span class="hljs-comment">// blocksize [same as filesize] </span><br><span class="hljs-comment">// filesize与blocksize这两个字段的值必须相等</span><br>&#125;; <br></code></pre></td></tr></table></figure><h4 id="定位l-info"><a href="#定位l-info" class="headerlink" title="定位l_info"></a>定位l_info</h4><p>最后一个program header的结尾处，就是l_info的起始处<br><img src="/images/2022/07/92264049.png" alt="0.png"></p><h4 id="定位p-info"><a href="#定位p-info" class="headerlink" title="定位p_info"></a>定位p_info</h4><p>l_info的结尾处，就是p_info的起始处<br><img src="/images/2022/07/2225615287.png" alt="1.png"></p><h3 id="修改UPX信息"><a href="#修改UPX信息" class="headerlink" title="修改UPX信息"></a>修改UPX信息</h3><h4 id="修改l-info-l-magic字段"><a href="#修改l-info-l-magic字段" class="headerlink" title="修改l_info.l_magic字段"></a>修改l_info.l_magic字段</h4><p>l_info.l_magic字段可能被修改成其它值，而且注意，文件中不止存在一除UPX!标记<br><img src="/images/2022/07/1596554270.png" alt="2.png"></p><p>一个被UPX壳处理过的文件中应该包含3处UPX!标记，如果UPX!标记被修改了，那么需要找到这3处修改并写回UPX!<br><img src="/images/2022/07/4164682838.png" alt="3.png"></p><p>需要注意，第1处UPX!出现在l_info中，第2,3处UPX!出现在文件末尾处，而且不属于任何section</p><h4 id="文件末尾附加信息"><a href="#文件末尾附加信息" class="headerlink" title="文件末尾附加信息"></a>文件末尾附加信息</h4><p>在标记以后的都是附加的多余信息，删除后才能使用upx -d进行脱壳<br><img src="/images/2022/07/2325433446.png" alt="4.png"></p><p>定位附加信息的方法就是，寻找到第3处UPX!标记，记它的起始位置为P，那么P + 0x24以前的数据才是有效的，P + 0x24以后的数据都是附加信息，需要去除<br><img src="/images/2022/07/3069284701.png" alt="5.png"></p><h4 id="p-info-p-fileszie-p-info-p-blocksize清0"><a href="#p-info-p-fileszie-p-info-p-blocksize清0" class="headerlink" title="p_info.p_fileszie, p_info.p_blocksize清0"></a>p_info.p_fileszie, p_info.p_blocksize清0</h4><p>定位到p_info后，发现p_info.p_filesize与p_info.p_blocksize字段都被清0了，需要恢复这个值<br><img src="/images/2022/07/933566901.png" alt="6.png"></p><p>定位到第3处UPX!标记，记它的起始位置为P，那么P + 0x18处就是p_info.p_filesize与p_info.blocksize字段的值，注意这两个字段的值是必须相等的<br><img src="/images/2022/07/3509142704.png" alt="7.png"></p><p>回填p_info字段即可完成修复<br><img src="/images/2022/07/1603430176.png" alt="8.png"></p><h3 id="修复代码"><a href="#修复代码" class="headerlink" title="修复代码"></a>修复代码</h3><p>需要安装pyelftools库以及upx，win下面需要把upx.exe所在目录添加到环境变量里，linux下直接包管理器安装即可<br>python unpack.py 样本目录<br>python unpack.py 样本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> genericpath <span class="hljs-keyword">import</span> isdir, isfile<br><span class="hljs-keyword">import</span> os<br><br><span class="hljs-keyword">from</span> elftools.elf.elffile <span class="hljs-keyword">import</span> ELFFile<br><span class="hljs-keyword">import</span> sys<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">usage</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Example: python unpack.py /mnt/e/upx_packed.elf&quot;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Example: python unpack.py /mnt/e/upx_packeds&quot;</span>)<br>    exit(-<span class="hljs-number">1</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">unpack_file</span>(<span class="hljs-params">file</span>):<br>    f = <span class="hljs-built_in">open</span>(file, <span class="hljs-string">&quot;rb+&quot;</span>)<br>    file_data = f.read()<br>    elf = ELFFile(f)<br><br>    <span class="hljs-keyword">if</span> elf.header[<span class="hljs-string">&quot;e_shoff&quot;</span>] != <span class="hljs-number">0</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;It seems that the file is not packed\n&quot;</span>);<br>        <span class="hljs-keyword">return</span><br><br>    l_info_ptr = elf.header[<span class="hljs-string">&quot;e_phoff&quot;</span>] + elf.header[<span class="hljs-string">&quot;e_phnum&quot;</span>] * elf.header[<span class="hljs-string">&quot;e_phentsize&quot;</span>]<br>    p_info_ptr = l_info_ptr + <span class="hljs-number">12</span><br><br>    l_info_magic = file_data[l_info_ptr + <span class="hljs-number">4</span> : l_info_ptr + <span class="hljs-number">8</span>]<br><br>    <span class="hljs-comment"># fix l_info.magic</span><br>    p = l_info_ptr + <span class="hljs-number">4</span><br>    l_info_magic_ptr = []<br>    <span class="hljs-keyword">while</span> p != -<span class="hljs-number">1</span>:<br>        l_info_magic_ptr.append(p)<br>        f.seek(p)<br>        f.write(<span class="hljs-string">b&quot;UPX!&quot;</span>)<br>        p = file_data.find(l_info_magic, p + <span class="hljs-number">1</span>)<br><br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(file_data) &gt; l_info_magic_ptr[<span class="hljs-built_in">len</span>(l_info_magic_ptr) - <span class="hljs-number">1</span>] + <span class="hljs-number">0x24</span>:<br>        f.truncate(l_info_magic_ptr[<span class="hljs-built_in">len</span>(l_info_magic_ptr) - <span class="hljs-number">1</span>] + <span class="hljs-number">0x24</span>)<br><br>    f.seek(l_info_magic_ptr[<span class="hljs-built_in">len</span>(l_info_magic_ptr) - <span class="hljs-number">1</span>] + <span class="hljs-number">0x18</span>)<br>    real_size = f.read(<span class="hljs-number">4</span>)<br>    f.seek(p_info_ptr + <span class="hljs-number">4</span>)<br>    f.write(real_size)<br>    f.write(real_size)<br>    f.close()<br><br>    os.system(<span class="hljs-string">&quot;upx -d &quot;</span> + file)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(sys.argv) &lt; <span class="hljs-number">2</span>:<br>        usage()<br>    <br><br>    <span class="hljs-keyword">if</span> os.path.isfile(sys.argv[<span class="hljs-number">1</span>]):<br>        unpack_file(sys.argv[<span class="hljs-number">1</span>])<br>    <span class="hljs-keyword">elif</span> os.path.isdir(sys.argv[<span class="hljs-number">1</span>]):<br>        p = sys.argv[<span class="hljs-number">1</span>]<br>        <span class="hljs-keyword">if</span> sys.platform.find(<span class="hljs-string">&quot;win&quot;</span>) != -<span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> p.endswith(<span class="hljs-string">&quot;\\&quot;</span>):<br>                p += <span class="hljs-string">&quot;\\&quot;</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> p.endswith(<span class="hljs-string">&quot;/&quot;</span>):<br>                p += <span class="hljs-string">&quot;/&quot;</span><br>        <span class="hljs-keyword">for</span> r <span class="hljs-keyword">in</span> os.listdir(p):<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> os.path.isfile(p + r):<br>                <span class="hljs-keyword">continue</span><br>            unpack_file(p + r)<br>    <span class="hljs-keyword">else</span>:<br>        usage()<br><br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    main()<br></code></pre></td></tr></table></figure><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol><li><a href="https://cujo.com/upx-anti-unpacking-techniques-in-iot-malware/">https://cujo.com/upx-anti-unpacking-techniques-in-iot-malware/</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>逆向</category>
      
    </categories>
    
    
    <tags>
      
      <tag>绿盟实习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IDA 窗口布局</title>
    <link href="/2022/07/14/IDA_%E7%AA%97%E5%8F%A3%E5%B8%83%E5%B1%80/"/>
    <url>/2022/07/14/IDA_%E7%AA%97%E5%8F%A3%E5%B8%83%E5%B1%80/</url>
    
    <content type="html"><![CDATA[<h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><p>之前一直不知道怎么拖动挑战IDA的窗口布局，真是铸币……</p><span id="more"></span><p>注意这里这个小灰条，把鼠标放上去，就会出现”drag this title to dock somewhere”<br><img src="/images/2022/07/3678850752.png" alt="0.png"></p><p>左键单击按住它，然后就可以拖动窗口了。可以把窗口合并进这个工具栏，只要把鼠标拖动到那上面松开就好了<br><img src="/images/2022/07/980298900.png" alt="2.png"></p><p>也可以把窗口拖动到其它窗口里面，达到窗口并列的效果</p><p>如果关闭了output窗口，可以在Window -&gt; output window菜单栏里面把它调出来</p>]]></content>
    
    
    <categories>
      
      <category>逆向</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IDA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IDA Pro Microcode 学习</title>
    <link href="/2022/07/12/IDA_Pro_Microcode_%E5%AD%A6%E4%B9%A0/"/>
    <url>/2022/07/12/IDA_Pro_Microcode_%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>我在绿盟实习参与的一个工作是代码相似度检测，我的mentor晖哥的做法是先完成binary code -&gt; ir的过程，再在ir的基础上进行相似度比较。这样做的优点是可以消除架构带来的差异，比如一个恶意软件家族可能会被编译到多个CPU架构上，为了检测出同家族不同架构恶意样本的相似度就必须克服这个难题，也就是将binary code提升到ir。因此，我开始调研IDA提供的Microcode。下文中出现的IR如无特殊说明全部指代Microcode</p><span id="more"></span><h3 id="IDA反编译器架构"><a href="#IDA反编译器架构" class="headerlink" title="IDA反编译器架构"></a>IDA反编译器架构</h3><p>产生IR代码 -&gt; 转换IR代码（进行各种优化化简IR代码） -&gt; 分别局部变量 -&gt; 产生ctree -&gt; 修饰ctree -&gt; 打印ctree（反汇编结果）</p><p>在早期，IDA只开放了操纵ctree的API。在IDA 7.0版本中，终于出现了操纵IR的API</p><h4 id="CTREE"><a href="#CTREE" class="headerlink" title="CTREE"></a>CTREE</h4><h5 id="AST"><a href="#AST" class="headerlink" title="AST"></a>AST</h5><p>ctree可以理解为ida反编译器输出源代码的ast。因此要了解ctree，首先要了解ast。以下面这段函数为例</p><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs nim"><span class="hljs-type">int</span> <span class="hljs-keyword">func</span>(<span class="hljs-type">int</span> a)<br>&#123;<br>  <span class="hljs-type">int</span> <span class="hljs-built_in">result</span>;<br>  <span class="hljs-keyword">if</span> ( a == <span class="hljs-number">1</span> )<br>  &#123;<br>    <span class="hljs-built_in">result</span> = <span class="hljs-number">5</span>;<br>  &#125;<br>  <span class="hljs-keyword">else</span><br>  &#123;<br>    <span class="hljs-built_in">result</span> = <span class="hljs-number">6</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">result</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/images/2022/07/4129722024.jpg" alt="hri_1.jpg"></p><p>start节点对应函数的入口，它的后继节点{2}代表empty block的后继基本块中有两条语句，它的两条边#1, #2的目标节点就是后继基本块中的第1与第2条语句。第1条语句是if (a == 1)，对应在ast中，它的后继节点有3个，分别对应判断条件，为真时的后继基本块，为假时的后继基本块，两个基本块都只有一条语句</p><h5 id="CTREE-1"><a href="#CTREE-1" class="headerlink" title="CTREE"></a>CTREE</h5><p>IDA反编译器使用ctree指代ast，ctree中的节点都是类cinsn_t或者cexpr_t的实例，这两个都是类citem_t类的子类</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">citem_t</span><br>&#123;<br>  <span class="hljs-type">ea_t</span> ea; <span class="hljs-comment">// 与这个节点有关的汇编代码的地址</span><br>  <span class="hljs-type">ctype_t</span> op; <span class="hljs-comment">// 节点类型</span><br>  ...<br>&#125;<br></code></pre></td></tr></table></figure><p>citem_t.op代表着节点类型，它的可能取值有两类：cot_xx与cit_xx，o指代operation，代表这个节点的类型是表达式，i指代instruction，代表节点的类型是指令。表达式的类型可以有：cot_asg (assign, x = y), cot_call (call, x(…))，指令的类型可以有cit_if (if语句), cit_return (return语句)</p><p>我们解析一个实际函数的CTREE，该函数如下图所示<br><img src="/images/2022/07/2995875403.png" alt="1.png"></p><p>函数的入口块有5条边，子节点是expr, expr, expr, if, if，对应反编译源代码中的前3条赋值语句与2条if语句。</p><p><img src="/images/2022/07/3629792851.png" alt="2.png"></p><p>第一个expr节点的子节点是asg，代表赋值操作。asg节点的左右子节点分别是var.4 v2与call，var.4中的.4代表变量长度是4字节。call节点的左子节点是目标地址与函数原型，右子节点是调用参数</p><p><img src="/images/2022/07/1398017589.png" alt="3.png"></p><p>第一个if节点的</p><p><img src="/images/2022/07/3613291921.png" alt="4.png"></p><p>ctree的产生也是分阶段的，反编译器会对产生的ctree进行一系列的优化。有如下若干个阶段的ctree，它们具有不同的成熟度<br><img src="/images/2022/07/2767392111.png" alt="17.png"></p><p>在idapython中，可以通过继承ida_hexrays.Hexrays_Hooks类，来注册反编译器行为的回调函数，通过重写maturity方法，可以接收ctree成熟度变化的信息</p><h4 id="IR"><a href="#IR" class="headerlink" title="IR"></a>IR</h4><h3 id="examples解析"><a href="#examples解析" class="headerlink" title="examples解析"></a>examples解析</h3><p>在&lt;IDA安装目录&gt;\python\examples\hexrays下，存在一系列有关IR与CTREE的examples。本节解析一下这些examples</p><h4 id="vds1-py"><a href="#vds1-py" class="headerlink" title="vds1.py"></a>vds1.py</h4><p>这个插件很简单，反编译一个函数，打印出伪代码<br><img src="/images/2022/07/3193069826.png" alt="14.png"></p><h4 id="vds3-py"><a href="#vds3-py" class="headerlink" title="vds3.py"></a>vds3.py</h4><p>这个插件的作用是对if-else语句做翻转变化，如下所示</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs gcode"><span class="hljs-comment">// 翻转前</span><br><span class="hljs-keyword">if</span> <span class="hljs-comment">(cond)</span><br>  stateme<span class="hljs-symbol">nt1</span>;<br>else<br>  stateme<span class="hljs-symbol">nt2</span>;<br><br><span class="hljs-comment">// 翻转后</span><br><span class="hljs-keyword">if</span> <span class="hljs-comment">(!cond)</span><br>  stateme<span class="hljs-symbol">nt2</span>;<br>else<br>  stateme<span class="hljs-symbol">nt1</span>;<br></code></pre></td></tr></table></figure><p>下面这段代码是一个标准插件的标准模板。关于这个模板的详细说明，请参考文献<a href="/images/2022/07/2767392111.png">6</a><br><img src="/images/2022/07/4234484464.png" alt="5.png"></p><p>这段代码是翻转if的主要逻辑，关键在于find_if_statement与invert_if这两个方法的实现<br><img src="/images/2022/07/2752911078.png" alt="7.png"></p><p>find_if_statement方法如下所示。这段代码的前半部分挺容易理解，就是判断当前选中的ctree中的节点是否为if节点，如果是的话就直接返回这个节点。问题在于后半部分，后半部分的代码的作用是当选中的语句是else时，回忆ctree一节中的内容，在ctree中是没有else节点的，它只会作为if节点的子节点出现。现在，我们面临的问题有两个：1. 判断选中的是否为else语句；2. 通过else语句寻找对应的if节点<br><img src="/images/2022/07/3569463680.png" alt="8.png"></p><p>判断选中的是否为else语句的条件是 vu.tail.citype == ida_hexrays.VDI_TAIL and vu.tail.loc.itp == ida_hexrays.ITP_ELSE，我们依次来解析一下这两条件</p><p>vdui_t.tail字段指明当前选中的item的tail节点<br><img src="/images/2022/07/44853894.png" alt="9.png"></p><p>VDI_TAIL常量的说明如下，意思是当前焦点坐标越过了当前行，停留在可以插入注释的地方，即行尾<br><img src="/images/2022/07/2863827999.png" alt="10.png"></p><p>vu.tail.loc是类treeloc_t的实例，在IDA SDK中，treeloc_t类的注释是”Ctree location. Used to denote comment locations.”，这个类是用来标注注释位置的，也就是说，在源代码中插入的注释应该和ctree中的某个节点关联起来，这个关联关系就使用treeloc_t类来确定</p><p>在ctree中，一个节点可能会被附加多个注释，比如一条if语句可以有如下这些注释。前3条注释都会被关联到if节点，但是这3条注释它们会有相同的ea（对应关联节点在汇编代码中的地址），为了区分这3条注释，引入了treeloc_t.ipt字段，它与ea共同标注注释。比如当取值为ITP_ELSE时，就说明这条注释是与if语句中的else关键字关联的</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-keyword">if</span> (...) &#123; <span class="hljs-regexp">//</span> 注释<span class="hljs-number">1</span><br>&#125; <span class="hljs-regexp">//</span> 注释<span class="hljs-number">2</span><br><span class="hljs-keyword">else</span> &#123; <span class="hljs-regexp">//</span> 注释<span class="hljs-number">3</span><br>&#125;<br></code></pre></td></tr></table></figure><p>treeloc_t.ipt字段可取的值如下<br><img src="/images/2022/07/3255716351.png" alt="11.png"></p><p>综合上面这些前置知识，可以得出判断选中的是else语句的条件，即，首先定位到选中行的行尾，获取注释信息，然后根据treeloc_t.ipt字段判断注释是否与else关键字关联，如果是的话，就说明选中的是else语句。然后通过treeloc_t.ea字段获取与注释关联的if节点在汇编代码中的地址，再通过地址在ctree中搜索即可寻找到与else语句关联的if节点</p><p>遍历ctree搜索if节点的代码如下<br><img src="/images/2022/07/560598955.png" alt="12.png"></p><p>invert_if方法的实现如下<br><img src="/images/2022/07/236423254.png" alt="13.png"></p><p>这个插件还有一些内容，主要就是把翻转过的if节点的地址记录在idb文件中，打开对应文件的时候自动再翻转一遍这些if节点。这与Microcode关系不大</p><h4 id="vds4-py"><a href="#vds4-py" class="headerlink" title="vds4.py"></a>vds4.py</h4><p>这个插件搜集用户自定义的信息并打印</p><p>打印用户注释，打印的字段包括treeloc_t.ea与treeloc_t.ipt与注释内容<br><img src="/images/2022/07/1641648373.png" alt="15.png"></p><p>剩余的代码也基本上是类似风格，不再赘述</p><h4 id="vds5-py"><a href="#vds5-py" class="headerlink" title="vds5.py"></a>vds5.py</h4><h4 id="vds6-py"><a href="#vds6-py" class="headerlink" title="vds6.py"></a>vds6.py</h4><h4 id="vds7-py"><a href="#vds7-py" class="headerlink" title="vds7.py"></a>vds7.py</h4><p>这个插件通过遍历ctree中的block节点dump出所有block</p><p>注册了反编译器的回调函数。注意这里是当ctree的成熟度为CMT_BUILD时dump所有block节点，CMT_BUILD阶段的ctree是刚刚产生的，与最终呈现的ctree相差甚远，所以可能会dump出很多最终反编译结果中不存在的节点<br><img src="/images/2022/07/1099185007.png" alt="16.png"></p><p>遍历ctree的代码如下。值得注意的是可以直接使用for ins in b语句来遍历block中的所有指令<br><img src="/images/2022/07/2650201803.png" alt="18.png"></p><h4 id="vds8-py"><a href="#vds8-py" class="headerlink" title="vds8.py"></a>vds8.py</h4><p>这个插件的作用是改善反编译结果，将svc指令反编译为函数调用</p><p>这段代码注册了个action，控制插件的功能开关。主要逻辑在udc_exit_t类中<br><img src="/images/2022/07/502890132.png" alt="19.png"></p><p>udc_exit_t类派生自udc_filter_t类<br><img src="/images/2022/07/2387469373.png" alt="20.png"></p><p>从udc_filter_t类定义可以看出，udc_exit_t类重写了init与match两个方法，install与uninstall方法都是调用install_microcode_filter函数安装/卸载filter<br><img src="/images/2022/07/624016660.png" alt="21.png"></p><p>microcode_filter_t类定义如下。注意它的说明，一个派生自microcode_filter_t类的类实例可以被注册用于非标准IR生成。在IR生成阶段，每个被注册的对象会按如下方式调用。也就是说，将汇编指令提升到IR时，是有一个标准IR生成的，这是对汇编指令的标准解析，但是也可以通过注册filter，进行非标准IR生成。在进行标准IR生成流程前，会先调用filter.match方法，如果返回的是MERR_OK，就调用filter.apply方法完成IR生成，当然这样就不需要进行标准IR生成流程了，这个过程就叫非标准IR生成</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs abnf">if ( filter-&gt;match(cdg) )<br>  code <span class="hljs-operator">=</span> filter-&gt;apply(cdg)<span class="hljs-comment">;</span><br>if ( code <span class="hljs-operator">=</span><span class="hljs-operator">=</span> MERR_OK ) <br>  continue<span class="hljs-comment">; // filter generated microcode, go to the next instruction</span><br></code></pre></td></tr></table></figure><p><img src="/images/2022/07/3616657268.png" alt="22.png"></p><p>udc_filter_t类派生自microcode_filter_t类，它的作用是在生成IR时，将符合条件的汇编指令翻译为为一条icall指令，icall指令的callee操作数由udc_filter_t.init方法确定<br><img src="/images/2022/07/379942362.png" alt="23.png"></p><h4 id="vds10-py"><a href="#vds10-py" class="headerlink" title="vds10.py"></a>vds10.py</h4><p>vds9.py运行于ASM -&gt; IR的阶段，vds10.py运行于IR优化阶段。它将<strong>call   !DbgRaiseAssertionFailure <a href="fast:">fast:</a>.0</strong>转换成<strong>call   !DbgRaiseAssertionFailure &lt;fast:”char *” “assertion text”&gt;.0</strong>，其中assertion text是从汇编代码的注释中提取的。DbgRaiseAssertionFailure是一个helper function，helper function是反编译器为了改善反编译器结果创造的不存在于原程序中的函数，比如 int 2c 指令，会被反编译器替换为__int2c()，其中__int2c这个函数就是helper function，选中后双击它是无法跟进这个函数体内部的，因为它并不存在于原程序中</p><p>这个插件在我的IDA 7.6上存在一点问题，以下面这段代码为例，IDA反编译器的结果是__int2c()而非DbgRaiseAssertionFailure()<br><img src="/images/2022/07/1852734967.png" alt="24.png"></p><p>我修改了下这个插件，让它寻找call __int2c(), 并将call __int2c()修改为call DbgRaiseAssertionFailure()<br><img src="/images/2022/07/756624582.png" alt="25.png"></p><p>插件的主要代码集中在类nt_assert_optimizer_t, 该类派生自optinsn_t类。optinsn_t类的定义如下。注释的意思是说，我们可以自己从optinsn_t类派生子类，实现func方法，注册回调之后，就可以对<strong>单条IR指令</strong>进行优化<br><img src="/images/2022/07/4135445173.png" alt="26.png"></p><p>optinsn_t.func方法原型如下。mblock_t * blk是指令所在block，也可能为null，为null就说明这条指令的优化必须与上下文无关；minsn_t * ins 待优化的指令，注意我们不能直接删除它，但可以把它改成nop作为替代，遍历这条指令的子指令需要通过派生minsn_visitor_t类进行，注意不能用nop替换子指令，但可以把它改成mov x,x；int optflags，文档并没有给出这个参数的具体取值；返回值是改变的指令数，注意如果改变了use/def链，必须调用mblock_t.mark_lists_dirty()标记污染以通知反编译器重新产生use/def链<br><img src="/images/2022/07/3952922062.png" alt="27.png"></p><p>具体优化过程在handle_nt_assert方法内。我们只是修改call指令的操作数，不会影响use/def链，所以无需进行标记工作。并且我们只会影响一条指令，所以返回值是1<br><img src="/images/2022/07/1228225139.png" alt="28.png"></p><p>handle_nt_assert方法如下<br><img src="/images/2022/07/4213138500.png" alt="29.png"></p><p>ins.d的类型是mop_t *, .f属性来自于mop_t类中的共用体。编码时，需要根据minsn_t.opcode确定指令，再根据指令使用mop_t中的共用体属性<br><img src="/images/2022/07/1932526864.png" alt="30.png"></p><p>反编译结果如下图所示<br><img src="/images/2022/07/3959183439.png" alt="31.png"><br><img src="/images/2022/07/1596223216.png" alt="32.png"></p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol><li><a href="https://recon.cx/2018/brussels/resources/slides/RECON-BRX-2018-Decompiler-internals-microcode.pdf">Decompiler internals: microcode</a></li><li><a href="https://hex-rays.com/blog/microcode-in-pictures/">Microcode in pictures</a></li><li><a href="https://www.hex-rays.com/blog/hex-rays-decompiler-primer">Hex-rays decompiler primer</a></li><li><a href="https://hex-rays.com/products/decompiler/manual/sdk/">IDA SDK</a></li><li><a href="https://github.com/patois/HRDevHelper">IDA CTREE图形化浏览插件</a></li><li><a href="https://hex-rays.com/blog/augmenting-ida-ui-with-your-own-actions/">Augmenting IDA UI with your own actions</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>逆向</category>
      
    </categories>
    
    
    <tags>
      
      <tag>绿盟实习</tag>
      
      <tag>IDA PRO</tag>
      
      <tag>IR</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>linux syscall桩函数符号恢复</title>
    <link href="/2022/07/11/linux_syscall%E7%AC%A6%E5%8F%B7%E6%81%A2%E5%A4%8D/"/>
    <url>/2022/07/11/linux_syscall%E7%AC%A6%E5%8F%B7%E6%81%A2%E5%A4%8D/</url>
    
    <content type="html"><![CDATA[<p>逆向IoT Linux的恶意样本的时候，经常会发现elf里不存在导入表，对os api的调用是通过syscall（mips, x86）或svc（arm）指令完成的</p><span id="more"></span><p><img src="/images/2022/07/4186953159.png" alt="0.png"></p><p><img src="/images/2022/07/1104786964.png" alt="1.png"></p><p>可以参考<a href="https://syscalls.w3challs.com/">linux syscall tables</a>进行符号恢复，这种都是很dirty的工作，于是写了一个ida脚本完成这项工作。MIPS O32架构的可以在这下载。其它架构的符号恢复可以在这个脚本的基础上修改完成，工作量挺小的<br><a href="/images/2022/07/1736832843.zip">mips_o32.zip</a></p><p>效果图</p><p><img src="/images/2022/07/183344089.png" alt="3.png"></p>]]></content>
    
    
    <categories>
      
      <category>APT</category>
      
      <category>逆向</category>
      
    </categories>
    
    
    <tags>
      
      <tag>绿盟实习</tag>
      
      <tag>IDA PRO</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++虚函数问题</title>
    <link href="/2022/07/07/C++%E8%99%9A%E5%87%BD%E6%95%B0%E9%97%AE%E9%A2%98/"/>
    <url>/2022/07/07/C++%E8%99%9A%E5%87%BD%E6%95%B0%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><p>今年四月份被浩天哥面了一次，浩天哥第一个问题就是C++菱形继承的逆向，直接把我干不会了，第二个问题是内存对齐，我答的也不是很好。最近看了会CMU的深入理解操作系统网课，第二个问题我应该能答好了。一般而言，OS的Cache缓存的单位是Block，一行中有若干Block，一组中有若干行。对Cache访问时，地址可以看成tag, 组索引, 块偏移3个部分。如果内存不对齐的话，很容易导致访问内存时导致跨Block读取，这会增加缓存未命中的概率。今天来写篇文章研究一下第一个问题</p><span id="more"></span><h3 id="简单的情况"><a href="#简单的情况" class="headerlink" title="简单的情况"></a>简单的情况</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> _a;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">a</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Function A.a\n&quot;</span>);<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> : <span class="hljs-keyword">public</span> A&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> _a;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">a</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Function B.a\n&quot;</span>);<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    A* a = <span class="hljs-keyword">new</span> <span class="hljs-built_in">B</span>();<br>    a-&gt;_a = <span class="hljs-number">1234</span>; <span class="hljs-comment">//1</span><br>    a-&gt;A::_a = <span class="hljs-number">5678</span>; <span class="hljs-comment">//2</span><br>    a-&gt;<span class="hljs-built_in">a</span>(); <span class="hljs-comment">//3</span><br>    a-&gt;A::<span class="hljs-built_in">a</span>(); <span class="hljs-comment">//4</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在x64平台上编译。语句1，2编译出的汇编指令相同，继承时，如果产生冲突，子类同名变量会覆盖掉父类变量，即使使用::域说明符也无法改变这个过程<br><img src="/images/2022/07/2571350809.png" alt="0.png"><br>语句3通过vftable调用B.a方法，语句4则直接调用了A.a方法。A, B的vftable结构如下，在B的vftable中，A.a被覆盖为B.a<br><img src="/images/2022/07/241303633.png" alt="1.png"></p><p>再考虑一下虚方法的继承情况</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> _a;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">a</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Function A.a\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">b</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Function A.b\n&quot;</span>);<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> : <span class="hljs-keyword">public</span> A&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> _a;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">a</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Function B.a\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">d</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Function B.d\n&quot;</span>);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>虚表结构如下<br><img src="/images/2022/07/4275583013.png" alt="2.png"><br>于是可以总结出B继承A时，虚表的继承步骤：</p><ol><li>先初始化B的虚表为A的虚表</li><li>如果发生了override的情况，在B的虚表中完成替换操作</li><li>将B的虚方法地址附加在B的虚表后</li></ol><p>再总结一下C++类的内存模型</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs diff">offset  说明<br><span class="hljs-addition">+0      指针指向虚表</span><br><span class="hljs-addition">+4/8    类变量</span><br></code></pre></td></tr></table></figure><h3 id="菱形继承"><a href="#菱形继承" class="headerlink" title="菱形继承"></a>菱形继承</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> _a;<br>    <span class="hljs-built_in">A</span>() &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;A初始化\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">a</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;A.a\n&quot;</span>);<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> : <span class="hljs-keyword">public</span> A &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> _b;<br>    <span class="hljs-built_in">B</span>() &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;B初始化\n&quot;</span>);<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span> : <span class="hljs-keyword">public</span> A &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> _c;<br>    <span class="hljs-built_in">C</span>() &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;C初始化\n&quot;</span>);<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">D</span> : <span class="hljs-keyword">public</span> B, <span class="hljs-keyword">public</span> C &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> _d;<br>    <span class="hljs-built_in">D</span>() &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;D初始化\n&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">d</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;D.d\n&quot;</span>);<br>    &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    D* d = <span class="hljs-keyword">new</span> <span class="hljs-built_in">D</span>();<br>    d-&gt;<span class="hljs-built_in">d</span>();<br>    d-&gt;_b = <span class="hljs-number">12</span>;<br>    d-&gt;_c = <span class="hljs-number">31</span>;<br>    d-&gt;_d = <span class="hljs-number">42</span>;<br>    d-&gt;B::_a = <span class="hljs-number">0xBB</span>;<br>    d-&gt;C::_a = <span class="hljs-number">0xCC</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>A是B, C的父类，D又派生自B, C。所以A,B,C,D的派生关系呈现出一个菱形的结构，称之为菱形继承。菱形继承的问题是，B,C中都包含一份A的虚表与类变量，因此D中最终包含两份A，这造成了很大的浪费<br>上述代码的输出是</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">A</span>初始化<br><span class="hljs-selector-tag">B</span>初始化<br><span class="hljs-selector-tag">A</span>初始化<br>C初始化<br>D初始化<br></code></pre></td></tr></table></figure><p>类D是类B与类C的子类，因此，要在类D维护两个this指针，this_B与this_C，调用B中的方法时，传递this_B，调用C中的方式时传递this_C。试看类D的初始化方法<br><img src="/images/2022/07/3102887765.png" alt="3.png"><br>为this_B与this_C设置vftable，注意this_B的vftable中包含D.d()，而this_C的vftable不包含D.d()，事实上this_B与this_D指向同一片内存<br><img src="/images/2022/07/1087637486.png" alt="4.png"><br><img src="/images/2022/07/1518854589.png" alt="5.png"><br>而后我们可以总结一下类D的this_D指向内存区域的内存布局</p><p>————-0x18————-  ————-0x18————-<br>D::vftable::for_B  类B的成员变量  D::vftable::for_C  类C的成员变量  类D的成员变量<br>D::vftable::for_B与D::vftable::for_C的内容都在上文</p><p>再对类D做一次继承，看看继承后的类布局</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">E</span> : <span class="hljs-keyword">public</span> D &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> _e;<br>    <span class="hljs-built_in">E</span>() &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;E初始化\n&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">e</span><span class="hljs-params">()</span>  </span>&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;E.e\n&quot;</span>);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>类E的初始化过程如下<br><img src="/images/2022/07/1645082814.png" alt="6.png"><br>E.e还是被放置在第1个vftable<br><img src="/images/2022/07/1705412928.png" alt="7.png"><br>对E._e的访问<br><img src="/images/2022/07/18026246.png" alt="8.png"><br>于是我们可以总结出类E的内存布局</p><table><thead><tr><th>0x38</th><th>0x08</th></tr></thead><tbody><tr><td>类D的内存布局(修改了类D的vftable)</td><td>类E的成员变量，E._e</td></tr></tbody></table><p>类似的，我们可以总结出类D多重继承自类A，类B，类C的内存布局（非虚继承情况）</p><p>|-|-|-|-|<br>|类A内存布局(修改了类A的vftable)|类B内存布局|类C内存布局|类D成员变量|</p><p>单继承的情况其实也可以这样写</p><p>|-|-|<br>|类A内存布局(修改了类A的vftable)|类B成员变量|</p><p>单类的内存布局</p><p>|-|-|<br>|指针，指向vatble|类成员变量|</p><p>自此，彻底搞清楚了无虚继承情况下，类、单类继承、多类继承的内存布局情况</p><h3 id="虚继承"><a href="#虚继承" class="headerlink" title="虚继承"></a>虚继承</h3><p>菱形继承会带来较大的空间浪费，使用虚继承可以避免这种情况。先考虑最简单的情况</p><h4 id="单类的虚继承"><a href="#单类的虚继承" class="headerlink" title="单类的虚继承"></a>单类的虚继承</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> _a;<br>    <span class="hljs-built_in">A</span>() &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;A初始化\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">a</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;A.a\n&quot;</span>);<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> : <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">public</span> A &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> _b;<br>    <span class="hljs-built_in">B</span>() &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;B初始化\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">b</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;B.b&quot;</span>);<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    B* b = <span class="hljs-keyword">new</span> <span class="hljs-built_in">B</span>();<br>    b-&gt;<span class="hljs-built_in">a</span>();<br>    b-&gt;<span class="hljs-built_in">b</span>();<br>    b-&gt;_b = <span class="hljs-number">0xBB</span>;<br>    b-&gt;_a = <span class="hljs-number">0xAA</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>B类虚继承自A类。可以看到B::B()多了一个参数，它为1时，代表进行虚继承的初始化，它为0时，代表进行普通继承的初始化<br><img src="/images/2022/07/3681687721.png" alt="9.png"><br>当a1为1时，进行虚继承初始化，可以看到，这段代码在this + 8处放置了一个vbtable指针，即virtual base table，即虚基类表，而后又调用A::A(this + 0x18)进行初始化<br><img src="/images/2022/07/3527814364.png" alt="10.png"><br>vbtable的结构如下，有两项dword值<br><img src="/images/2022/07/994201872.png" alt="11.png"><br>下一步的初始化动作是修改类B实例的vftable，再使用this[vbtable<a href="/images/2022/07/2571350809.png">1</a> + 8] = vftable_for_A。我们暂时可以推测出vbtable的结构</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">vbtable</span> &#123;<br>  <span class="hljs-type">int</span> unknown;<br>  <span class="hljs-type">int</span> offset_of_vftable; <span class="hljs-comment">// vftable的偏移，自vbtable的地址开始算起，比如在B类实例中，A类的vbtable的地址是this + 8，那么在B类实例中，A类的vftable的地址应该是 this + 8 + offset_of_vftable</span><br>&#125;<br></code></pre></td></tr></table></figure><p>而后访问类B的虚基类A的成员变量，虚函数等，都是通过vbtable.offse_of_vftable完成的<br><img src="/images/2022/07/2708131805.png" alt="13.png"><br><img src="/images/2022/07/1705766799.png" alt="14.png"></p><p>现在我们可以总结一下类B虚继承类A时，类B的内存布局情况，如下图所示<br><img src="/images/2022/07/3413038564.png" alt="虚继承.png"></p><p>注意观察vftable_for_B中不存在从类A继承而来的虚函数</p><p><img src="/images/2022/07/787970881.png" alt="15.png"></p><h4 id="普通继承一个虚继承得到的类"><a href="#普通继承一个虚继承得到的类" class="headerlink" title="普通继承一个虚继承得到的类"></a>普通继承一个虚继承得到的类</h4><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs xl">class F : public B &#123; <span class="hljs-comment">//类B是通过虚继承类A得到的</span><br>public:<br>    int _f;<br>    virtual void f() &#123;<br>        printf(<span class="hljs-string">&quot;F.f\n&quot;</span>);<br>    &#125;<br>&#125;;<br><br>int main() &#123;<br>    F* f = new F();<br>    <span class="hljs-function"><span class="hljs-title">f</span>-&gt;</span>_a = <span class="hljs-number">0</span>xAA;<br>    <span class="hljs-function"><span class="hljs-title">f</span>-&gt;</span>_b = <span class="hljs-number">0</span>xBB;<br>    <span class="hljs-function"><span class="hljs-title">f</span>-&gt;</span>_f = <span class="hljs-number">0</span>xFF;<br>    <span class="hljs-function"><span class="hljs-title">f</span>-&gt;</span>a();<br>    <span class="hljs-function"><span class="hljs-title">f</span>-&gt;</span>b();<br>    <span class="hljs-function"><span class="hljs-title">f</span>-&gt;</span>f();<br>&#125;<br></code></pre></td></tr></table></figure><p>我们研究一下类F的内存布局。从对F::F()调用的参数a1来看，初始化类F实例时会设置vbtable</p><p><img src="/images/2022/07/2211469083.png" alt="17.png"></p><p>可以观察到，类A实例位于this + 0x20，类B实例位于this + 0x0。同时，设置了vftable_for_F</p><p><img src="/images/2022/07/2196465835.png" alt="18.png"></p><p>观察一下vftable_for_F，发现它已经包含了F.f()</p><p><img src="/images/2022/07/3522408507.png" alt="19.png"></p><p>再观察一下F._a, F._b, F._c对应this指针的偏移，我们知道了类内存布局</p><p><img src="/images/2022/07/720849610.png" alt="20.png"></p><p>类B虚继承自类A，类C普通继承自类A</p><p><img src="/images/2022/07/1742605041.png" alt="虚继承2.png"></p><p>与上一节中的普通单继承的类内存布局其实很相似，我们给它打一个补丁：需要把虚基类放在内存布局的最末尾，就可以兼容那个继承框架</p><h4 id="存在公共虚基类的情况"><a href="#存在公共虚基类的情况" class="headerlink" title="存在公共虚基类的情况"></a>存在公共虚基类的情况</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> _a;<br>    <span class="hljs-built_in">A</span>() &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;A初始化\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">a</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;A.a\n&quot;</span>);<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> : <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">public</span> A &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> _b;<br>    <span class="hljs-built_in">B</span>() &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;B初始化\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">b</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;B.b&quot;</span>);<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span> : <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">public</span> A &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> _c;<br>    <span class="hljs-built_in">C</span>() &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;C初始化\n&quot;</span>);<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">D</span> : <span class="hljs-keyword">public</span> B, <span class="hljs-keyword">public</span> C &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> _d;<br>    <span class="hljs-built_in">D</span>() &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;D初始化\n&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">d</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;D.d\n&quot;</span>);<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">E</span> : <span class="hljs-keyword">public</span> D &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> _e;<br>    <span class="hljs-built_in">E</span>() &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;E初始化\n&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">e</span><span class="hljs-params">()</span>  </span>&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;E.e\n&quot;</span>);<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    B* b = <span class="hljs-keyword">new</span> <span class="hljs-built_in">B</span>();<br>    b-&gt;<span class="hljs-built_in">a</span>();<br>    b-&gt;<span class="hljs-built_in">b</span>();<br>    b-&gt;_b = <span class="hljs-number">0xBB</span>;<br>    b-&gt;_a = <span class="hljs-number">0xAA</span>;<br>    <br><br><br>    D* d = <span class="hljs-keyword">new</span> <span class="hljs-built_in">D</span>();<br>    d-&gt;<span class="hljs-built_in">d</span>();<br>    d-&gt;_b = <span class="hljs-number">12</span>;<br>    d-&gt;_c = <span class="hljs-number">31</span>;<br>    d-&gt;_d = <span class="hljs-number">42</span>;<br>    d-&gt;B::_a = <span class="hljs-number">0xBB</span>;<br>    d-&gt;C::_a = <span class="hljs-number">0xCC</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在我们来考虑更复杂的情况，B, C虚继承A，D多继承B, C。运行后的输出如下，A的构造函数确实只执行了一次</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-variable">A</span>初始化<br><span class="hljs-variable">B</span>初始化<br><span class="hljs-built_in">C</span>初始化<br><span class="hljs-built_in">D</span>初始化<br><span class="hljs-built_in">D</span><span class="hljs-operator">.</span><span class="hljs-variable">d</span><br></code></pre></td></tr></table></figure><p>我们尝试研究一下这种情况下类D的内存布局。对类D进行初始化，注意到参数a1为1，说明会设置vbtable<br><img src="/images/2022/07/3762695059.png" alt="16.png"><br>在D的初始化方法中，首先设置了类B与类C实例的vbtable，并且初始化了一个类A实例，注意类B与类C实例的vbtable.offset_of_vftable都指向刚刚初始化的类A实例，这说明B与D共享同一个类A实例！</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-number">1.</span><span class="hljs-keyword">this</span> + <span class="hljs-number">0x08</span>=vbtable D::<span class="hljs-keyword">for</span> B<br><span class="hljs-number">2.</span><span class="hljs-keyword">this</span> + <span class="hljs-number">0x20</span>=vbtable D::<span class="hljs-keyword">for</span> C<br><span class="hljs-number">3.</span><span class="hljs-keyword">this</span> + <span class="hljs-number">0x38</span>=A::A(<span class="hljs-keyword">this</span> + <span class="hljs-number">0x38</span>)<br></code></pre></td></tr></table></figure><p><img src="/images/2022/07/1169776688.png" alt="21.png"><br><img src="/images/2022/07/559868875.png" alt="22.png"></p><p>再看D::D()的后续代码，注意调用了B::B(), C::C()，但传参a1都是0。传参a1为0则表示不需要初始化虚基类，传参a1为1则表示需要初始化虚基类，当类包含虚基类时，类的构造函数是会由编译器隐式包含a1参数的</p><p>再来看B::B(this + 0x0, 0)</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-number">4.</span><span class="hljs-keyword">this</span> + <span class="hljs-number">0x00</span>=B::B(<span class="hljs-keyword">this</span> + <span class="hljs-number">0x00</span>, <span class="hljs-number">0</span>)<br>因为<span class="hljs-keyword">this</span> + <span class="hljs-number">0x08</span>已经是vbtable D::<span class="hljs-keyword">for</span> B，所以，无需再初始化vbtable<br><span class="hljs-number">4.1</span> <span class="hljs-keyword">this</span> + <span class="hljs-number">0x00</span>=B::vftable&#123;<span class="hljs-keyword">for</span> B&#125;<br><span class="hljs-number">4.2</span><span class="hljs-keyword">this</span> + <span class="hljs-number">0x38</span>=B::vftable&#123;<span class="hljs-keyword">for</span> A&#125;<br></code></pre></td></tr></table></figure><p><img src="/images/2022/07/1538100346.png" alt="23.png"></p><p>再看C::C(this + 0x18, 0)</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-number">5.</span><span class="hljs-keyword">this</span> + <span class="hljs-number">0x18</span>=C::C(<span class="hljs-keyword">this</span> + <span class="hljs-number">0x18</span>, <span class="hljs-number">0</span>)<br><span class="hljs-number">5.1</span> <span class="hljs-keyword">this</span> + <span class="hljs-number">0x18</span> =C::vftable&#123;<span class="hljs-keyword">for</span> C&#125;<br><span class="hljs-number">5.2</span> <span class="hljs-keyword">this</span> + <span class="hljs-number">0x38</span>=C::vftable&#123;<span class="hljs-keyword">for</span> A&#125;<br></code></pre></td></tr></table></figure><p>初始化完类B实例与类C实例后的进一步动作如下</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-number">6.</span><span class="hljs-keyword">this</span> + <span class="hljs-number">0x00</span>=D::vftable&#123;<span class="hljs-keyword">for</span> B&#125;<br><span class="hljs-number">7.</span><span class="hljs-keyword">this</span> + <span class="hljs-number">0x18</span>=D::vftable&#123;<span class="hljs-keyword">for</span> C&#125;<br><span class="hljs-number">8.</span><span class="hljs-keyword">this</span> + <span class="hljs-number">0x38</span>=D::vftable&#123;<span class="hljs-keyword">for</span> A&#125;<br></code></pre></td></tr></table></figure><p><img src="/images/2022/07/99300111.png" alt="24.png"></p><p>再来看对D.a(), D.b(), D.c(), D.d()的调用。对D.a的调用需要通过vbtable间接进行，但对D.b与D.c的调用都是通过vftable直接完成的，因为D.a方法是通过虚继承得到的，而D.b与D.c方法都是普通继承得到的，对应D.d方法的调用显然直接通过vftable完成<br><img src="/images/2022/07/1097173390.png" alt="25.png"></p><p>实际上，我们可以画出D类的内存布局。注意D中仅仅存在一份类A的实例，完结撒花~~~<br><img src="/images/2022/07/723160184.png" alt="虚继承3.png"></p>]]></content>
    
    
    <categories>
      
      <category>逆向</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>逆向</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
